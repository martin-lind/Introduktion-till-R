[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduktion till R",
    "section": "",
    "text": "Introduktion till statistisk analys i R för biologer\nHemsidan är under uppbyggnad, en första version beräknas vara färdig i februari 2026, och kommer kontinuerligt att fyllas på med material.\nHemsidan byggs av Martin Lind, Högskolan i Halmstad och Uppsala Universitet."
  },
  {
    "objectID": "tutorials/linear-regression/index.html",
    "href": "tutorials/linear-regression/index.html",
    "title": "Linjär regression",
    "section": "",
    "text": "En regressionsanalys används om man är intresserad av ett orsakssamband mellan två kontinuerliga variabler. Den man är intresserad av att förklara och som är y-axeln i en graf kallas responsvariabel (eller beroende variabel) medan den variabel som man vill förklara med kallas prediktor (eller oberoende variabel) och utgör x-axeln.\nDen enklaste typen av regression är en linjär regression. När man behärskar den linjära regressionen kan den enkelt byggas ut för att även studera icke-linjära samband, olika regressionslinjer för olika grupper och ännu mer avancerade samband.\nEn linjär regression har följande krav på datat\nResidual En residual är skillnaden mellan ett mätvärda av responsvariabeln och det förutsagda värdet av responsvariabeln om det hade varit placerat exakt på regressionslinjen. Ju längre från linjen (i y-led) en punkt ligger, desto större residual."
  },
  {
    "objectID": "tutorials/linear-regression/index.html#overview",
    "href": "tutorials/linear-regression/index.html#overview",
    "title": "Linear Regression in R",
    "section": "",
    "text": "In this tutorial we learn how to fit linear models in R."
  },
  {
    "objectID": "tutorials/linear-regression/index.html#dataset",
    "href": "tutorials/linear-regression/index.html#dataset",
    "title": "Linear Regression in R",
    "section": "Dataset",
    "text": "Dataset\nDownload the dataset here: Download housing data"
  },
  {
    "objectID": "tutorials/linear-regression/index.html#load-data",
    "href": "tutorials/linear-regression/index.html#load-data",
    "title": "Linear Regression in R",
    "section": "Load data",
    "text": "Load data\n\n\nCode\n#housing &lt;- read.csv(\"data/housing.csv\")\n#summary(housing)"
  },
  {
    "objectID": "tutorials/linear-regression/index.html#screenshots-figures-and-teaching-friendly-options",
    "href": "tutorials/linear-regression/index.html#screenshots-figures-and-teaching-friendly-options",
    "title": "Linear Regression in R",
    "section": "8. Screenshots, figures, and teaching-friendly options",
    "text": "8. Screenshots, figures, and teaching-friendly options\nHighly recommended options for teaching:\nformat:\n  html:\n    toc: true\n    toc-depth: 3\n    code-fold: show\n    code-summary: \"Show R code\""
  },
  {
    "objectID": "tutorials/index.html",
    "href": "tutorials/index.html",
    "title": "Tutorials",
    "section": "",
    "text": "Installera R\nAnvända R, en introduktion\nInstallera paket\nLäsa in data i R\n\n\n\n\n\nt-test\nLinjär regression\nKorrelation\nEnvägs ANOVA\n\\(\\chi\\) 2 test (Chi-2)\nTransformeringar [Under utveckling]\nIcke-parametriska tester [Under utveckling]\nFaktoriell (flervägs) ANOVA [Under utveckling]\nAncova [Under utveckling]"
  },
  {
    "objectID": "tutorials/index.html#lista-över-tutorials",
    "href": "tutorials/index.html#lista-över-tutorials",
    "title": "Tutorials",
    "section": "",
    "text": "Installera R\nAnvända R, en introduktion Ej påbörjad\nInstallera paket\nLäsa in data i R\n\n\n\n\n\nt-test Ej påbörjad\nLinjär regression Ej påbörjad\nAnova Ej påbörjad\nKorrelation Ej påbörjad\nChi2 Ej påbörjad\n\n\n\n\n\nUtvecklingstest av funktioner och kod Test"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Om",
    "section": "",
    "text": "Hemsidan är tänkt att användas i statistikutbildning för biologer, med fokus på utbildningen vid Högskolan i Halmstad. På sikt skall den även fungera som en referens för vanliga analysmetoder.\nHemsidan är skriven i Quarto, implementerat i R Studio.\nAnsvarig för hemsidan är Martin Lind"
  },
  {
    "objectID": "tutorials/testbed/index.html",
    "href": "tutorials/testbed/index.html",
    "title": "Linear Regression in R",
    "section": "",
    "text": "In this tutorial we learn how to fit linear models in R."
  },
  {
    "objectID": "tutorials/testbed/index.html#overview",
    "href": "tutorials/testbed/index.html#overview",
    "title": "Linear Regression in R",
    "section": "",
    "text": "In this tutorial we learn how to fit linear models in R."
  },
  {
    "objectID": "tutorials/testbed/index.html#dataset",
    "href": "tutorials/testbed/index.html#dataset",
    "title": "Linear Regression in R",
    "section": "Dataset",
    "text": "Dataset\nDownload the dataset here: Download housing data"
  },
  {
    "objectID": "tutorials/testbed/index.html#load-data",
    "href": "tutorials/testbed/index.html#load-data",
    "title": "Linear Regression in R",
    "section": "Load data",
    "text": "Load data\n\n\nCode\n#housing <- read.csv(\"data/housing.csv\")\n#summary(housing)"
  },
  {
    "objectID": "tutorials/testbed/index.html#screenshots-figures-and-teaching-friendly-options",
    "href": "tutorials/testbed/index.html#screenshots-figures-and-teaching-friendly-options",
    "title": "Linear Regression in R",
    "section": "8. Screenshots, figures, and teaching-friendly options",
    "text": "8. Screenshots, figures, and teaching-friendly options\nHighly recommended options for teaching:\nformat:\n  html:\n    toc: true\n    toc-depth: 3\n    code-fold: show\n    code-summary: \"Show R code\""
  },
  {
    "objectID": "tutorials/read-data/index.html",
    "href": "tutorials/read-data/index.html",
    "title": "Läsa in data i R",
    "section": "",
    "text": "Det första steget, innan man gör en statistisk analys, är alltid att läsa in data i R.\nVi kommer att gå igen följande:"
  },
  {
    "objectID": "tutorials/read-data/index.html#dataformat",
    "href": "tutorials/read-data/index.html#dataformat",
    "title": "Läsa in data i R",
    "section": "Dataformat",
    "text": "Dataformat\nR kan hantera ett stort antal dataformat, vissa av dem läses automatiskt, andra kräver att man laddar ner och installerar specialiserade paket.\n\nVanliga datatyper som R kan läsa in (många fler alternativ finns)\n\n\nFiländelse\nBeskrivning\nFunktion\nExtra paket krävs\nKommentarer\n\n\n\n\ntxt\nTab-avgränsad text\nread.table()\n-\n\n\n\ncsv\nKomma/semikolon-avgränsad text\nread.csv()\n-\nSpecificera om avgränsningen är “,” eller “;”\n\n\nxlsx\nExceldokument\nread.xlsx()\nopenxlsx\nSe paketets dokumentation\n\n\nrda rdata\nR-datafil\nload()\n\n\n\n\nsas7bdat sas7bcat dta sav\nSAS\nStata\nSPSS\nread_sas()\nread_dta()\nread_sav()\nhaven\nSe paketets dokumentation\n\n\n\nVi har redan testat att läsa in en tab-avgänsad textfil (txt-fil)i avsnittet Läs in filen ovan. Nu skall vi testa på några andra filtyper."
  },
  {
    "objectID": "tutorials/read-data/index.html#vilket-sätt-skall-en-fil-läsas-in-på",
    "href": "tutorials/read-data/index.html#vilket-sätt-skall-en-fil-läsas-in-på",
    "title": "Läsa in data i R",
    "section": "Vilket sätt skall en fil läsas in på?",
    "text": "Vilket sätt skall en fil läsas in på?\nDet finns många sätt att läsa in en fil, det beror dels på om du använder R eller R Studio, men också på om du vill dokumentera vad filen heter och var den är placerad (rekommenderas för reproducerbarhet). Slutligen kan valet bero på om du använder R-projekt eller inte.\nNedan kommer vi gå igen följande metoder:\n\n\n\nMetod\nBeskrivning\n\n\n\n\nRelativ sökväg till filen\nDu anger först vilken mapp din fil ligger i (din Working Directory) och sedan vad filen heter\n\n\nAbsolut sökväg till filen\nDu anger exakt var filen ligger på din hårddisk och vad den heter\n\n\n\nVilken metod man använder är en smaksak, båda metoderna är vanliga och man bör känna till båda."
  },
  {
    "objectID": "tutorials/read-data/index.html#exempel-läsa-in-en-txt-i-r",
    "href": "tutorials/read-data/index.html#exempel-läsa-in-en-txt-i-r",
    "title": "Läsa in data i R",
    "section": "Exempel: Läsa in en txt i R",
    "text": "Exempel: Läsa in en txt i R\nI följande exempel läser vi in en tab-avgränsad datafil med filändelsen txt i R.\nMetoden bygger på att vi vill ha den absoluta sökvägen till våran datafil (dvs var på hårddisken den ligger), det är en bra metod att använda sig av för att alltid veta vilken fil, man arbetar med.\nFördel\n\nGer en absolut sökväg (du hittar alltid vilken fil du arbetar med)\n\nNackdel\n\nAtt få reda på den absoluta sökvägen kan vara lite omständigt (men behöver bara göras en gång per dataset)\n\n\nTa reda på den absoluta sökvägen till din fil med data\nAlla filer ligger någonstans på din hårddisk."
  },
  {
    "objectID": "tutorials/read-data/index.html#exempel-läsa-in-en-txt-i-r-med-absolut-sökväg",
    "href": "tutorials/read-data/index.html#exempel-läsa-in-en-txt-i-r-med-absolut-sökväg",
    "title": "Läsa in data i R",
    "section": "Exempel: Läsa in en txt i R med absolut sökväg",
    "text": "Exempel: Läsa in en txt i R med absolut sökväg\nI följande exempel läser vi in en tab-avgränsad datafil med filändelsen txt i R.\nMetoden bygger på att vi vill ha den absoluta sökvägen till vår datafil (dvs var på hårddisken den ligger), det är en bra metod att använda sig av för att alltid veta vilken fil man arbetar med.\nFördel\n\nGer en absolut sökväg (du hittar alltid vilken fil du arbetar med)\n\nNackdel\n\nAtt få reda på den absoluta sökvägen kan vara lite omständigt (men behöver bara göras en gång per dataset)\n\n\nTa reda på den absoluta sökvägen till din fil med data\nLadda ner följande fil testdata.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk.\nNästa steg är att tala om för R var på din hårddisk du har sparat filen (den absoluta sökvägen till filen).\nDet enklaste sättet att få reda på den absoluta sökvägen är att öpna din filhanterare (finder, utforskaren eller liknande) och leta upp filen. Sedan drar du filen och släpper den i R-konsolen. Då kommer du få se dess sökväg, vilket visas i blått på en Mac (samt ev felmeddelanden eftersom du gör något som R inte förstår, men R ger dig sökvägen, vilket är vad vi vill ha).\n\n\n\n\n\nSökvägen till filen på min dator är: ~/git_projects/Introduktion-till-R/tutorials/read-data/data/testdata.txt\nR Studio - om du använder R studio fungerar det inte att dra filen till konsolen. Istället kan du öppna din terminal (Terminal, iTerm, EMAC, MobaXterm etc) och släppa filen där. Eller gör det i vanliga R. Då får du en sökväg.\n\n\n\nSökväg till filen om man släpper den i en terminal (iTerm i exemplet)\n\n\n\n\nLäs in filen i R\nVi kommer att läsa in filen med funktionen read.table().\n\n\nCode\ntestdata &lt;- read.table(\"data/testdata.txt\",\n                     header=T,\n                     sep=\"\\t\",\n                     dec=\",\") \n\n\n&lt;- betyder att vi sparar resultatet av funktionen (just nu read.table()) i ett objekt. Eftersom det är vårt data är objektet en dataframe. Pilen &lt;- pekar på objektet, och vi ger det ett passande namn, i det här fallet testdata.\nread.table() är funktionen för att läsa in textfiler med filändelsen .txt\n\"data/testdata.txt\" är sökvägen till datafilen, dvs där den är sparad på din hårddisk (data/), och namnet på filen (testdata.txt).\nheader=T betyder att den första raden i datafilen är en rubrikrad och inte består av data. Det är nästan alltid fallet om du läser in en datafil till R. Om även första raden består av data (dvs det finns inga rubriker) ersätter du T med F (T står för TRUE, F står för FALSE).\nsep=T betyder att alla värden/celler är separerade med TAB (det är en tab-separerad textfil).\ndec=\",\" betyder att kommatecken används som decimalseparator (ex 1,32). Om filen istället använder punkt som decimalseparator (ex 1.32), anger du istället dec=\".\""
  },
  {
    "objectID": "tutorials/read-data/index.html#inspektera-ditt-data",
    "href": "tutorials/read-data/index.html#inspektera-ditt-data",
    "title": "Läsa in data i R",
    "section": "Inspektera ditt data",
    "text": "Inspektera ditt data\nNästa steg är att insprektera ditt dataset, för att se om allt gått rätt till vid inläsningen.\nBörja med att inspektera datasetets struktur med str().\n\n\nCode\nstr(testdata)\n\n\n'data.frame':   10 obs. of  3 variables:\n $ Colour: chr  \"Green\" \"Green\" \"Green\" \"Green\" ...\n $ Weight: int  4 3 5 4 5 12 14 15 11 14\n $ Length: num  1.3 1.1 3.4 2.5 7.1 14.5 16.9 13.5 9.4 11\n\n\n$ Colour: chr betyder att värderna i Colour kolumnen är bokstäver (characters)\n$ Weight: int betyder att värderna i kolumnen Weight är heltal (integers)\n$ Length: num betyder att värderna i kolumnen Length är decimaltal (numeric)\nOm du har en kolumn som borde innehålla decimaltal, skall det stå num. Om det istället står chr betyder det att datafilen har punkt som decimalavskiljare, men du utgår från att det är komma (eller tvärtom) och därmed tror R att det är text. Ändra avskiljare, ex från dec=\",\" till dec=\".\" i koden och importera datasetet på nytt.\nSedan visar du de första raderna i ditt dataset med funktionen head() och verifierar att allt ser korrekt ut.\n\n\nCode\nhead(testdata)\n\n\n  Colour Weight Length\n1  Green      4    1.3\n2  Green      3    1.1\n3  Green      5    3.4\n4  Green      4    2.5\n5  Green      5    7.1\n6   Blue     12   14.5\n\n\nOm allt ser korrekt ut så är du redo att analysera ditt data!"
  },
  {
    "objectID": "tutorials/install-R/index.html",
    "href": "tutorials/install-R/index.html",
    "title": "Installera R",
    "section": "",
    "text": "R är ett programmeringsspråk som används för statistik och visualisering av data. Det är i språket R vi skriver när vi arbetar med R.\nR är också en mjukvara (ett program) som vi använder oss av när vi gör statistik och visualiseringar i språket R."
  },
  {
    "objectID": "tutorials/install-R/index.html#r-programmet",
    "href": "tutorials/install-R/index.html#r-programmet",
    "title": "Installera R",
    "section": "R (programmet)",
    "text": "R (programmet)\nR är fritt tillgängligt utan kostnad, och finns för alla större plattformar (OSX, Windows, Unix, Linux mm).\n\n\n\n\n\nLadda ner R här"
  },
  {
    "objectID": "tutorials/install-R/index.html#rstudio",
    "href": "tutorials/install-R/index.html#rstudio",
    "title": "Installera R",
    "section": "RStudio",
    "text": "RStudio\nRStudio är ett alternativt grafiskt interface (GUI) till R. För att använda RStudio krävs att du redan har installerat programmet R.\n\n\n\n\n\nLadda ner RStudio här"
  },
  {
    "objectID": "tutorials/install-R/index.html#r-eller-rstudio",
    "href": "tutorials/install-R/index.html#r-eller-rstudio",
    "title": "Installera R",
    "section": "R eller RStudio?",
    "text": "R eller RStudio?\nSåväl R som RStudio hanterar R-kod på samma sätt (eftersom RStudio använder sig av R i bakgrunden) och det spelar ingen roll vilken man använder för att göra statistik och visualiseringar.\nRStudio utmärker sig genom ett annorlunda interface och hjälpsamma funktioner såsom tab completion, färgning av kod (ger bättre överblick) och möjligheter till avancerad organisering av dina projekt. Dessutom kan RStudio hantera fler programmeringsspråk och enkelt integreras i vanliga arbetsflöden (ex via github)."
  },
  {
    "objectID": "tutorials/R-packages/index.html",
    "href": "tutorials/R-packages/index.html",
    "title": "R-paket",
    "section": "",
    "text": "Alla grundläggande funktioner ingår redan i R och finns tillgängliga vid uppstart. En stor styrka med R är dock att det går att bygga ut med paket som ger nya funktioner. Det kan exampelvis vara avancerade statistiska analyser eller grafer. Det är den stora mängden specialiserade paket, utvecklad av aktiva forskare inom alla discipliner, som gör R till det ledande verktyget för dataanalys och statistik."
  },
  {
    "objectID": "tutorials/R-packages/index.html#vanliga-paket",
    "href": "tutorials/R-packages/index.html#vanliga-paket",
    "title": "R-paket",
    "section": "Vanliga paket",
    "text": "Vanliga paket\nNedan listas några vanliga paket inom biologisk statistik.\n\n\n\nPaket\nAnvändning\n\n\n\n\nggplot2\nGrafer och visualiseringar\n\n\nopenxlsx\nLäsa in Excel-dokument\n\n\ndplyr\nBearbeta datafiler, göra urval av data\n\n\nlme4\nMixed-effect modeller\n\n\ncar\nSignifikansberäkning i mixed-effect modeller\n\n\nvegan\nMultivariat statistik och biodiversitetsanalyser"
  },
  {
    "objectID": "tutorials/R-packages/index.html#installera-paket",
    "href": "tutorials/R-packages/index.html#installera-paket",
    "title": "R-paket",
    "section": "Installera paket",
    "text": "Installera paket\nDu installerar ett paket genom funktionen install.packages()\nSom ett exempel kan vi installera paketet ggplot2\ninstall.packages(\"ggplot2\")"
  },
  {
    "objectID": "tutorials/R-packages/index.html#använda-ett-paket",
    "href": "tutorials/R-packages/index.html#använda-ett-paket",
    "title": "R-paket",
    "section": "Använda ett paket",
    "text": "Använda ett paket\nNär du startar R är inga paket laddade i körningen, även om paketen är installerade. För att använda paketet måste du ladda in det i R, vilket du gör med funktionen library().\nVi laddar nu in det nyligen installerade paketet ggplot2 i R.\n\n\nCode\nlibrary(ggplot2)"
  },
  {
    "objectID": "tutorials/R-packages/index.html#dokumentera-vilka-paket-som-ingår-i-ett-viss-script",
    "href": "tutorials/R-packages/index.html#dokumentera-vilka-paket-som-ingår-i-ett-viss-script",
    "title": "R-paket",
    "section": "Dokumentera vilka paket som ingår i ett viss script",
    "text": "Dokumentera vilka paket som ingår i ett viss script\nOm du använder en viss funktion som utförs av ett paket, men inte har installerat och laddat paketet, kommur du få ett felmeddelande.\nHur vet du då vilket paket som skall användas? Kommer du ihåg det? Eller har du fått en scriptfil från en kollega? Det är allstå väldigt viktigt att dokumentera vilka extra paket som används i en viss analys.\n\nDokumentera i början av scriptfilen\nEtt vanligt sätt är att börja sin scriptfil med att lista alla paket som används. Då kan du (eller den som du delar din scriptfil med) se vilka paket som används.\n\n\n\n\n\nDet här är det absolut vanligaste sättet att dokumentera vilka paket man använder sig av, och det räcker troligtvis för dina behov.\nNackdelen med att enbart använda sig av det här tillvägagångssättet är att du inte vet vilken funktion som hör till vilket paket. Det är inget praktiskt problem, men ett “ordningsproblem”\n\n\nDokumentera varje gång du använder en funktion från ett paket\nI tillägg till att lista alla paketen först i scriptet är ett extra bra sätt är att tala om vilket paket en funktion tillhör. Det gör du genom att skriva ut paketets namn varje gång du använder den funktionen:\npaketnamn::funktion\nExempel om man gör en figur med ggplot2:\nggplot2::ggplot(...)\nMetoden ger en väldigt bra tydlighet och reproducerbarhet, och används när så är önskvärt."
  },
  {
    "objectID": "tutorials/read-data/index.html#använda-relativ-sökväg",
    "href": "tutorials/read-data/index.html#använda-relativ-sökväg",
    "title": "Läsa in data i R",
    "section": "Använda relativ sökväg",
    "text": "Använda relativ sökväg\nDen absoluta sökvägen till en fil är ofta lång och ibland omständig att få fram. Ett alternativ är att istället använda relativa sökvägar.\nEn relativ sökväg är sökvägen till en fil, relativt den foldern du befinner dig i just nu.\nPlatsen du befinner dig just nu är din Working Direcory, och du kan själv bestämma vad som är din Working Directory. Troligtvis har du alla filer som tillhör ett visst projekt i en mapp på din hårddisk, då hade det varit smart att ange den mappen som din Working Directory.\nDu kan se var din Working Directory är just nu genom funktionen getwd()\nTesta att undersöka var din Working Directory är\n\n\nCode\ngetwd()\n\n\n[1] \"/Users/martin/git_projects/Introduktion-till-R/tutorials/read-data\"\n\n\nDu kan därefter skriva in den absoluta sökvägen till din Working Directory genom funktionen setwd()\n\nAnvänd menyerna\nEtt alternativt sätt att ta dig fram till din Working Directory är att använda dig av menyerna.\nAnvänd menyerna för att välja mappen där du sparat filen testdata.txt som din nya Working Directory!\nI R kan du välja Working Directory genom att klicka följande i menyerna:\n\nI RStudio finns motsvarande menyval\n\nDet är dock bra att dokumentera din Working Directory i ditt script, så att du inte behöver sätta den manuellt nästa gång du skall arbeta med samma data.\nEfter att du ställt in rätt Working Directory i menyerna, gör följande:\n\nTa du reda på den absoluta sökvägen till din Working Directory med getwd()\n\n\n\nCode\ngetwd()\n\n\n[1] \"/Users/martin/git_projects/Introduktion-till-R/tutorials/read-data\"\n\n\n\nSkriv in den absoluta sökvägen i ditt script, inuti funktionen setwd()\n\n\n\nCode\nsetwd(\"/Users/martin/git_projects/Introduktion-till-R\")\n\n\nNästa gång du öppnar R och ditt script så räcker det att köra raden med setwd() där du just fyllt i din sökväg, så hamnar du direkt i din mapp!\n\n\nLäs in filen\nNu är din Working Directory samma mapp som filen testdata.txt ligger i. När du nu läser in din fil behöver du inte ange dess absoluta sökväg, det räcker att ange dess filnamn!\ntestdata &lt;- read.table(\"testdata.txt\", header=T,sep=\"\\t\", dec=\",\")\nSe Läs in filen i R för vår tidigare beskrivning av hur man tolkar de olika delarna av funktionen read.table()."
  },
  {
    "objectID": "tutorials/read-data/index.html#använd-menyerna",
    "href": "tutorials/read-data/index.html#använd-menyerna",
    "title": "Läsa in data i R",
    "section": "Använd menyerna",
    "text": "Använd menyerna\nEtt alternativt sätt att ta dig fram till din Working Directory är att använda dig av menyerna.\nI R kan du välja Working Directory genom att klicka följande i menyerna:\n\nI RStudio finns motsvarande menyval\n\nDet är dock bra att dokumentera din Working Directory i ditt script, så att du inte behöver sätta den manuellt nästa gång du skall arbeta med samma data.\nEfter att du ställt in rätt Working Directory i menyerna, gör följande:\n\nTa du reda på den absoluta sökvägen till din Working Directory med getwd()\n\n\n\nCode\ngetwd()\n\n\n[1] \"/Users/martin/git_projects/Introduktion-till-R/tutorials/read-data\"\n\n\n\nSkriv in den absoluta sökvägen i ditt script, inuti funktionen setwd()\n\n\n\nCode\nsetwd(\"/Users/martin/git_projects/Introduktion-till-R\")\n\n\nNästa gång du öppnar R och ditt script så räcker det att köra raden med setwd() där du just fyllt i din sökväg, så hamnar du direkt i din mapp!"
  },
  {
    "objectID": "tutorials/read-data/index.html#absolut-sökväg-till-filen",
    "href": "tutorials/read-data/index.html#absolut-sökväg-till-filen",
    "title": "Läsa in data i R",
    "section": "Absolut sökväg till filen",
    "text": "Absolut sökväg till filen\nEtt alternativ är att ange den absoluta sökvägen till filen, dvs exakt var den ligger på din hårddisk, det är en bra metod att använda sig av för att alltid veta vilken fil man arbetar med och är fördelaktig om man arbetar med filer som är spridda i olika mappar på din dator. Det är oklokt att ändra Working Directory under en pågående analys, och det är också oklokt att ha mer än en kopia av samma fil på din hårddisk. För att undvika det kan man använda absoluta sökvägar.\nFördel\n\nGer en absolut sökväg (du hittar alltid vilken fil du arbetar med)\n\nNackdel\n\nOm du arbetar med många olika filer som alla ligger i samma mapp kan det vara smidigast med relativ sökväg\n\n\nTa reda på den absoluta sökvägen till din fil med data\nLadda ner filen testdata.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en annan mapp än där du sparade filen i förra exemplet.\nNästa steg är att tala om för R var på din hårddisk du har sparat filen (den absoluta sökvägen till filen).\n\n\nSökväg via file.choose()\nDet enklaste sättet är att använda funktionen file.choose(). Skriv in den funktionen utan att fylla i något inom paranteserna. Du kommer då att få upp en dialogruta där du letar upp din fil och väljer den. R kommer då ge dig den absoluta sökvägen till filen, i mitt fall blev det:\n[“data/testdata.txt”]\nMarkera och kopiera sökvägen, den använder vi när vi läser in filen i R\n\n\nLäs in filen i R\nVi kommer åter att läsa in filen med funktionen read.table() och vi kallar vårt inlästa dataset testdata_absolut.\n\n\nCode\ntestdata_absolut <- read.table(\"data/testdata.txt\",\n                     header=T,\n                     sep=\"\\t\",\n                     dec=\",\") \n\n\nNotera att vi nu har en längre sökväg till filen.\n\"data/testdata.txt\" är sökvägen till datafilen, dvs där den är sparad på din hårddisk (data/), och namnet på filen (testdata.txt). Du ersätter den här texten med sökvägen till din fil som du kopierade i steget ovan.\nSe Läs in filen i R för vår tidigare beskrivning av hur man tolkar de olika delarna av funktionen read.table(). Efter att du läst in filen skall du alltid Inspektera ditt data innan du börjar med dina analyser.\n\n\nCode\nstr(testdata_absolut)\n\n\n'data.frame':   10 obs. of  3 variables:\n $ Colour: chr  \"Green\" \"Green\" \"Green\" \"Green\" ...\n $ Weight: int  4 3 5 4 5 12 14 15 11 14\n $ Length: num  1.3 1.1 3.4 2.5 7.1 14.5 16.9 13.5 9.4 11\n\n\nCode\nhead(testdata_absolut)\n\n\n  Colour Weight Length\n1  Green      4    1.3\n2  Green      3    1.1\n3  Green      5    3.4\n4  Green      4    2.5\n5  Green      5    7.1\n6   Blue     12   14.5\n\n\n\n\nSökväg via din filhanterare + terminal\nOm du redan har filen framme i din filhanterare (finder, utforskaren eller liknande) så är ett alternativt sätt att få reda på den absoluta sökvägen är att du drar filen och släpper den i R-konsolen. Då kommer du få se dess sökväg, vilket visas i blått på en Mac (samt ev felmeddelanden eftersom du gör något som R inte förstår, men R ger dig sökvägen, vilket är vad vi vill ha).\n\n\n\n\n\nSökvägen till filen på min dator är: ~/git_projects/Introduktion-till-R/tutorials/read-data/data/testdata.txt\nR Studio - om du använder R studio fungerar det inte att dra filen till konsolen. Istället kan du öppna din terminal (Terminal, iTerm, EMAC, MobaXterm etc) och släppa filen där. Eller gör det i vanliga R. Då får du en sökväg.\n\n\n\nSökväg till filen om man släpper den i en terminal (iTerm i exemplet)"
  },
  {
    "objectID": "tutorials/read-data/index.html#relativ-sökväg-till-filen",
    "href": "tutorials/read-data/index.html#relativ-sökväg-till-filen",
    "title": "Läsa in data i R",
    "section": "Relativ sökväg till filen",
    "text": "Relativ sökväg till filen\nMed relativ sökväg menas att du först anger vilken mapp filen ligger i, och sedan vad filen heter.\nLadda ner följande fil testdata_v2.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en mapp med ett lämpligt namn.\nNästa steg är att tala om för R var på din hårddisk du har sparat filen, dvs vad som är sökvägen till mappen som filen ligger i. Sedan kan du tala om för R vilken fil i mappen du skall läsa in.\n\nVar är jag?\nPlatsen du befinner dig just nu är din Working Direcory, och du kan själv bestämma vad som är din Working Directory. Troligtvis har du alla filer som tillhör ett visst projekt i en mapp på din hårddisk, då hade det varit smart att ange den mappen som din Working Directory.\nDu kan se var din Working Directory är just nu genom funktionen getwd()\nTesta att undersöka var din Working Directory är\n\n\nCode\ngetwd()\n\n\n[1] \"/Users/martin.lind/git_projects/Introduktion-till-R/tutorials/read-data\"\n\n\n\n\nÄndra din Working Directory\nEtt enkelt sätt att ändra din Working Directory är att använda dig av menyerna.\nAnvänd menyerna för att välja mappen där du sparat filen testdata_v2.txt som din nya Working Directory!\nI R kan du välja Working Directory genom att klicka följande i menyerna:\n\nI RStudio finns motsvarande menyval\n\nNu har du ställt in din Working Directory så att det är den mappen som filerna du vill arbeta med ligger i!\nDet är dock bra att dokumentera din Working Directory i ditt script, så att du inte behöver sätta den manuellt i menyerna nästa gång du skall arbeta med samma data. Det gör också att du minns var filerna ligger.\nEfter att du ställt in rätt Working Directory i menyerna, gör följande:\n\nTa du reda på den absoluta sökvägen till din Working Directory med getwd() . Markera och kopiera sökvägen.\n\n\n\nCode\ngetwd()\n\n\n[1] \"/Users/martin.lind/git_projects/Introduktion-till-R/tutorials/read-data\"\n\n\n\nSkriv in (eller klistra in) den absoluta sökvägen i ditt script, inuti funktionen setwd()\n\nsetwd(\"/Users/martin/git_projects/Introduktion-till-R\")\nNästa gång du öppnar R och ditt script så räcker det att köra raden med setwd() där du just fyllt i din sökväg till din Working Directory, så hamnar du direkt i din mapp och kan läsa in dina filer!\n\n\nLäs in filen\nNu är din Working Directory samma mapp som filen testdata.txt ligger i.\nVi kommer att läsa in filen med funktionen read.table().\n\n\nCode\ntestdata <- read.table(\"testdata_v2.txt\",\n                     header=T,\n                     sep=\"\\t\",\n                     dec=\",\") \n\n\n<- betyder att vi sparar resultatet av funktionen (just nu read.table()) i ett objekt. Eftersom det är vårt data är objektet en dataframe. Pilen <- pekar på objektet, och vi ger det ett passande namn, i det här fallet testdata.\nread.table() är funktionen för att läsa in textfiler med filändelsen .txt\n\"testdata_v2.txt\" är sökvägen till datafilen, och eftersom den ligger direkt i din Working Directiory behöver vi bara skriva ut namnet på filen (testdata_v2.txt).\nheader=T betyder att den första raden i datafilen är en rubrikrad och inte består av data. Det är nästan alltid fallet om du läser in en datafil till R. Om även första raden består av data (dvs det finns inga rubriker) ersätter du T med F (T står för TRUE, F står för FALSE).\nsep=T betyder att alla värden/celler är separerade med TAB (det är en tab-separerad textfil).\ndec=\",\" betyder att kommatecken används som decimalseparator (ex 1,32). Om filen istället använder punkt som decimalseparator (ex 1.32), anger du istället dec=\".\""
  },
  {
    "objectID": "tutorials/read-data/index.html#läsa-in-csv-fil",
    "href": "tutorials/read-data/index.html#läsa-in-csv-fil",
    "title": "Läsa in data i R",
    "section": "Läsa in csv-fil",
    "text": "Läsa in csv-fil\nEn csv-fil är en fil där värderna är avgränsade av komma eller semikolon. Det är en mycket vanlig filtyp att långtidslagra data i.\nLadda ner filen testdata_csv.csv och spara den någonstans på din hårddisk.\nEfter det letar du upp filen, antingen genom att använda Relativ sökväg till filen eller Absolut sökväg till filen. Om du sparat den i samma mapp som du har din Working Directory är det enkelt att använda en relativ sökväg.\n\nLäs in filen\nVi kommer åter att läsa in filen med funktionen read.csv(). Fyll i korrekt sökväg till din fil\n\n\nCode\ntestdata_csv <- read.csv(\"data/testdata_csv.csv\",\n                     header=T,\n                     sep=\";\",\n                     dec=\",\") \n\n\nVi sparar resultatet från funktionen read.csv(), vilket är ett dataset, med namnet testdata_csv. Man skall alltid använda olika namn för olika dataset.\nsep=\";\" betyder att värderna i filen är separerade av semikolon. I övrigt påminner funktionen om read.table() som beskrivits i detalj ovan (Läs in filen). Efter att du läst in filen skall du alltid Inspektera ditt data innan du börjar med dina analyser.\n\n\nCode\nstr(testdata_csv)\n\n\n'data.frame':   10 obs. of  3 variables:\n $ Colour: chr  \"Red\" \"Red\" \"Red\" \"Red\" ...\n $ Weight: int  7 4 3 4 5 12 14 15 11 14\n $ Length: num  2.3 4.1 3.4 2.5 7.1 14.5 16.9 13.5 9.4 11\n\n\nCode\nhead(testdata_csv)\n\n\n  Colour Weight Length\n1    Red      7    2.3\n2    Red      4    4.1\n3    Red      3    3.4\n4    Red      4    2.5\n5    Red      5    7.1\n6  White     12   14.5"
  },
  {
    "objectID": "tutorials/read-data/index.html#läsa-in-excelfil",
    "href": "tutorials/read-data/index.html#läsa-in-excelfil",
    "title": "Läsa in data i R",
    "section": "Läsa in Excelfil",
    "text": "Läsa in Excelfil\nDe flesta som samlar in biologiska data skriver in sina värden i Excel, och exporterar sedan sina data som en txt eller csv fil. Det kan därför vara lockande att direkt läsa in sina excelblad i R, utan att gå omvägen via export till ett annat format.\nFördelar med att direkt läsa in excelfiler\n\nDu har bara en enda fil med data, det är ingen risk att du lägger in nya data i Excel men glömmer att exportera det som txt eller csv-fil\n\nNackdelar med att direkt läsa in excelfiler\n\nExcel har ett propriärt format, det är inte säkert att dina filer kan läsas i framtiden, därmed bättre att spara dina data i ett öppet format som txt eller csv\nDet är bra att separera sina excelfiler (där pågående datainsamling skrivs in) från ditt färdiga data (din txt eller csv-fil) som inte skall manipuleras\nExcelbladet du läser in måste vara helt rent, dvs du får inte ha några celler med annan information än data (exempelvis inga grafer, blanka kolumner eller liknande).\n\nLadda ner filen testdata_excel.xlsx och spara den någonstans på din hårddisk.\nEfter det letar du upp filen, antingen genom att använda Relativ sökväg till filen eller Absolut sökväg till filen. Om du sparat den i samma mapp som du har din Working Directory är det enkelt att använda en relativ sökväg.\n\nLäsa in Excelfilen\nFör att kunna läsa in en Excelfil behöver vi installera paketet openxlsx. Se den tidigare informationen i kapitlet om att installera paket för en fullständig genomgång om hur man hanterar paket.\nDu installerar paketet med koden install.packages(\"openxlsx\")\nNär paketet är installerat behöver vi läsa in det i vår pågående session i R\n\n\nCode\nlibrary(openxlsx)\n\n\nNu är paketet inläst och vi kan använda oss av funktionen read.xlsx() för att läsa in vår Excelfil.\n\n\nCode\ntestdata_excel <- read.xlsx(\"data/testdata_excel.xlsx\",\n                     sheet=1) \n\n\nsheet=1 betyder att du läser in det första bladet i Exceldokumentet.\nEfter att du läst in filen skall du alltid Inspektera ditt data innan du börjar med dina analyser.\n\n\nCode\nstr(testdata_excel)\n\n\n'data.frame':   10 obs. of  3 variables:\n $ Colour: chr  \"Purple\" \"Purple\" \"Purple\" \"Purple\" ...\n $ Mass  : num  2 5 3 5 5 12 14 15 11 14\n $ Width : num  12.3 14.1 12.4 12.5 17.1 20.5 26.9 23.5 19.4 21\n\n\nCode\nhead(testdata_excel)\n\n\n  Colour Mass Width\n1 Purple    2  12.3\n2 Purple    5  14.1\n3 Purple    3  12.4\n4 Purple    5  12.5\n5 Purple    5  17.1\n6 Yellow   12  20.5"
  },
  {
    "objectID": "tutorials/t-test/index.html",
    "href": "tutorials/t-test/index.html",
    "title": "t-test",
    "section": "",
    "text": "Ett t-test (kallas även Student´s t-test) används när man är intresserad om huruvida två grupper av en faktor skiljer sig åt i medelvärde. Om man har fler än två grupper, eller har flera faktorer, använder man sig istället av Anova, vilket vi kommer använda oss av senare under kursen.\nEtt t-test förutsätter följande"
  },
  {
    "objectID": "tutorials/t-test/index.html#läs-in-data",
    "href": "tutorials/t-test/index.html#läs-in-data",
    "title": "t-test",
    "section": "Läs in data",
    "text": "Läs in data\nVi vill undersöka om växtbiomassan i ett antal odlingskrukor skiljer sig beroende på om de fått hög eller låg näring.\nLadda ner följande fil experiment_nutrients.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en mapp med ett lämpligt namn.\nFortsätt med att läsa in datasetet och ge det ett namn, i det här fallet kallar vi det nutrientdata. En detalerad beskrivning i hur man läser in filer finns i vår tidigare tutorial Läsa in data i R.\nGlöm inte att dokumentera din kod i ett script, med kommentarer som förklarar vad du gör! Se vår tutorial om script om du behöver påminnelse om hur man skapar och använder script.\n\n\nCode\nnutrientdata <- read.table(\"data/experiment_nutrients.txt\",\n                           header=T,\n                           sep=\"\\t\",\n                           dec=\",\") \n\n\n<- betyder att vi sparar resultatet av funktionen (i det här fallet read.table() i ett objekt. Pilen pekar på objektet, och vi ger objektet ett namn, i det här fallet nutrientdata.\nread.table är kommandot för att läsa in textfiler med ändelsen .txt\n\"data/experiment_nutrients.txt\" är sökvägen till platsen där datafilen är sparad på din dator(data/), samt namnet på filen (experiment_nutrients.txt).\nheader=Tbetyder att första raden i filen är kolumnernas rubriker, dvs inte värden.\nsep=T betyder att alla värden är separerade med TAB.\ndec=\",\" betyder att komma används som decimalavgränsare (ex. 1,32)."
  },
  {
    "objectID": "tutorials/t-test/index.html#inspektera-data",
    "href": "tutorials/t-test/index.html#inspektera-data",
    "title": "t-test",
    "section": "Inspektera data",
    "text": "Inspektera data\nBörja med att titta på datans struktur med str().\n\n\nCode\nstr(nutrientdata)\n\n\n'data.frame':   20 obs. of  2 variables:\n $ Nutrient_level: chr  \"High\" \"High\" \"High\" \"High\" ...\n $ Mass          : num  15.5 11.7 15.9 13.7 13.2 ...\n\n\n$ Nutrient_level: chr betyder att värderna i kolumnen Nutrient_level är karaktärer dvs text och inte siffror.\n$ Mass: num betyder att värderna i kolumnen Mass är decimaltal\nOm du har en kolumn som innehåller decimaltal skall det stå num. Om det istället står chr betyder det att datat har punkt som decimalavgränsare, medan du läste in det med komma som avgränsare (eller tvärtom) och R tror att det är text. Justera koden och läs in datat på nytt (se vår tidigare tutorial Läsa in data i R för justerad kod).\nVisa sedan de fem första raderna av ditt dataset med head() för att se att allt ser korrekt ut\n\n\nCode\nhead(nutrientdata)\n\n\n  Nutrient_level     Mass\n1           High 15.45038\n2           High 11.65872\n3           High 15.92761\n4           High 13.74627\n5           High 13.20712\n6           High 14.79113"
  },
  {
    "objectID": "tutorials/t-test/index.html#visualisera-datat-med-en-enkel-graf",
    "href": "tutorials/t-test/index.html#visualisera-datat-med-en-enkel-graf",
    "title": "t-test",
    "section": "Visualisera datat med en enkel graf",
    "text": "Visualisera datat med en enkel graf\nVi gör en enkel graf med boxplot()\n\n\nCode\nboxplot(Mass~Nutrient_level, \n        data = nutrientdata)\n\n\n\n\n\nDen grå boxen innehåller de mittersta 50% av värderna i gruppen, och den horisontella linjen i mitten visar medianvärdet. Felstaplarna visar området som de 25% lägsta och 25% högsta värderna ligger i.\nObservera: en boxplot är INTE ett statistiskt test, och det motsvarar inte medelvärden och varians/standard error. Använd det enbart för snabb inspektion av data, inte för publicering. Vi går igenom hur man gör en publiceringsduglig graf i den avslutande delen av vår tutorial, under Publiceringsduglig figur\nHur tolkar du grafen? Ser det ut som att växtbiomassan skiljer sig åt beroende på näring?"
  },
  {
    "objectID": "tutorials/t-test/index.html#statistisk-modellering",
    "href": "tutorials/t-test/index.html#statistisk-modellering",
    "title": "t-test",
    "section": "Statistisk modellering",
    "text": "Statistisk modellering\nVi vill nu göra ett t-test för att undersöka om vår responsvariabel (beroende variabel) Mass beror av vår förklarande variabel (oberoende variabel) Nutrient_level, med andra ord om biomassan beror av näringstillgången.\nVi specificerar en modell med hjälp av funktionen t.test() och väljer att spara resultatet i ett objekt som vi kallar m.garden. Jag föredrar att alla mina modeller (resultat av statistka test) har ett namn som börjar med m. för att jag skall veta vad som är dataset och vad som är modeller. Ge alltid dina modeller beskrivande namn.\n\n\nCode\nm.nutrients<-t.test(Mass~Nutrient_level,\n                    data=nutrientdata)\n\n\nI vår modell har vi vår responsvariabel (det vi har på y-axeln) till vänster om tilde-tecknet ~ och vår förklarande variabel till höger. data=nutrientdata betyder att vi använder oss av datasetet vi tidigare döpt till nutrientdata.\n\nStatistiska resultat\nVi tittar på resultatet genom att skriva in modellens namn och köra den\n\n\nCode\nm.nutrients\n\n\n\n    Welch Two Sample t-test\n\ndata:  Mass by Nutrient_level\nt = 3.7581, df = 16.853, p-value = 0.001588\nalternative hypothesis: true difference in means between group High and group Low is not equal to 0\n95 percent confidence interval:\n 1.681385 5.992311\nsample estimates:\nmean in group High  mean in group Low \n          14.53003           10.69318 \n\n\nVi kan nu inspektera resultatet. Vi får teststatistika (t-värde) samt frihetsgrader (df) och ett p-värde.\nEftersom vårt p-värde är mindre än 0.05 säger vi att biomassan skiljer sig signifikant mellan de två näringsbehandlingarna Vi ser att medelvärdet i grupp High är högre än i grupp Low. Stämmer det om du tittar på din boxplot?"
  },
  {
    "objectID": "tutorials/t-test/index.html#presentera-din-statistiska-analys",
    "href": "tutorials/t-test/index.html#presentera-din-statistiska-analys",
    "title": "t-test",
    "section": "Presentera din statistiska analys",
    "text": "Presentera din statistiska analys\nVäxtbiomassan är större i hög näring än i låg näring (t-test, t = 3.758, d.f. = 16.9, p = 0.002)."
  },
  {
    "objectID": "tutorials/t-test/index.html#utvärdera-den-statistiska-modellen",
    "href": "tutorials/t-test/index.html#utvärdera-den-statistiska-modellen",
    "title": "t-test",
    "section": "Utvärdera den statistiska modellen",
    "text": "Utvärdera den statistiska modellen\nVar modellen lämplig att använda för ditt dataset?\nVi utvärderar modellen genom diagnostiska grafer\n\n\nCode\nqqnorm (nutrientdata$Mass)\nqqline(nutrientdata$Mass)\n\n\n\n\n\nNormal Q-Q visar om residualerna är normalfördelade. De bör följa en tänkt diagonal linje från nedre vänster hörn till övre höger hörn. Om de avviker på ett systematiskt sätt är residualerna inte perfekt normalfördelade, och vi kan behöva förändra modellen, exempelvis genom att transformera data eller använda ett annat typ av test."
  },
  {
    "objectID": "tutorials/use-R/index.html",
    "href": "tutorials/use-R/index.html",
    "title": "Använda R, en introduktion",
    "section": "",
    "text": "Vi skall nu öppna R (eller RStudio), bekanta oss med hur man skriver in och kör kod, och hur man använder script."
  },
  {
    "objectID": "tutorials/use-R/index.html#utseende-r-programmet",
    "href": "tutorials/use-R/index.html#utseende-r-programmet",
    "title": "Använda R, en introduktion",
    "section": "Utseende R (programmet)",
    "text": "Utseende R (programmet)\nUtseendet på R ser olika ut beroende på operativsystem, vid uppstart ser man endast en konsol, och man öppnar ett nytt fönster när man öppnar en skriptfil. Figurer hamnar i ytterligare ett fönster."
  },
  {
    "objectID": "tutorials/use-R/index.html#utseende-rstudio",
    "href": "tutorials/use-R/index.html#utseende-rstudio",
    "title": "Använda R, en introduktion",
    "section": "Utseende RStudio",
    "text": "Utseende RStudio\nRStudio är ett alternativt grafiskt interface (GUI) till R. Dess utseende är detsamma oberoende av operativsystem, och dess interface är uppdelat så att olika fönster (script, konsol, grafer osv) alltid ligger på samma plats. Rutan för scripts syns endast om du har öppnat en scriptfil."
  },
  {
    "objectID": "tutorials/use-R/index.html#skriv-din-första-kod",
    "href": "tutorials/use-R/index.html#skriv-din-första-kod",
    "title": "Använda R, en introduktion",
    "section": "Skriv din första kod",
    "text": "Skriv din första kod\nVi skall nu börja interagera med R, och vi gör det till en början interaktivt, det vill säga vi skriver kommandon direkt i konsolen.\nKlicka i konsolen, så att din markör hamnar på den nedersta raden, efter > - tecknet. Skriv 1+1 och tryck på Enter. När du trycker på Enter så kör du koden, dvs det du skrivit på raden läses av R, och R genomför ditt kommando. I det här fallet ber du R att addera 1 med 1, och R ger dig svaret på nästa rad, dvs 2.\nR är en excellent miniräknare, och eftersom du ser din formel kan du lätt dubbelkolla att du gjorde rätt. Mycket bättre än att använda mobiltelefonens kalkylator.\nR kan även med enkelhet hantera potenstal. Testa att skriva följande:\n\n\nCode\n10^2\n\n\n[1] 100\n\n\n\n\nCode\n1.24e-3\n\n\n[1] 0.00124\n\n\nAtt ta kvadratroten ur ett tal är inga problem:\n\n\nCode\nsqrt(8)\n\n\n[1] 2.828427\n\n\nR känner också till matematiska konstanter, som till exempel pi\n\n\nCode\npi\n\n\n[1] 3.141593\n\n\n\nObjekt i R\nR kan spara information i något som kallas objekt. Ett objekt kan innehålla olika typer av information, det kan vara ett tal, en nummerserie, ett namn, ett dataset, resultatet av en statistisk analys, en funktion eller mycket annat. Vi väljer ofta att spara olika resultat som objekt för att kunna återanvända dem, men också för att göra vår kod tydligare.\nVi skall nu göra en övning i att använda objekt. Övningen är väldigt enkel och skulle enkelt kunna genomföras utan att gå vägen via objekt, men den illustrerar väl tankesättet och logiken med objekt.\nLåt oss beräkna hur stor del av EUs länder du har besökt. Fundera på hur många det är. Vi skapar sedan ett objekt som vi kallar visited_countries och det objektet skall innehålla ett tal som motsvarar det antal länder du besökt.\n\n\nCode\nvisited_countries <- 12\n\n\nLåt oss titta på formeln. visited_countries är namnet på vårt objekt. Det skall fyllas med innehåll. Du vill fylla det med det antalet EU-länder du besökt. Då skriver du <- vilket är en pil som pekar på objektet. Efter pilen skriver du det antalet länder du besökt, exemelvis 12. Pilen går från talet 12 till vårt objekt, dvs du sparar talet 12 i vårt objekt.\nVill du se vad ett objekt innehåller skriver du objektets namn och trycker på Enter.\n\n\nCode\nvisited_countries\n\n\n[1] 12\n\n\nFör att beräkna andelen av EUs länder du besökt måste vi göra ett objekt som vi kallar total_countries och som innehåller antalet länder som är medlemmar i EU\n\n\nCode\ntotal_countries <- 27\n\n\nNu kan vi beräkna andelen av EUS länder som du besökt, genom att dividera objektet visited_countries med total_countries\n\n\nCode\nvisited_countries / total_countries\n\n\n[1] 0.4444444\n\n\nDu kanske hellre vill ha det i procent? Modifiera formeln!\n\n\nCode\nvisited_countries / total_countries * 100\n\n\n[1] 44.44444\n\n\nDu kanske skall använda det här resultatet i framtida beräkningar och vill ha det sparat som ett objekt. Modifiera den senaste formeln så att du sparar resultatet som ett objekt du kallar percent_EUcountries_visited\n\n\nCode\npercent_EUcountries_visited <- visited_countries / total_countries * 100\n\n\nUndersök vad objektet percent_EUcountries_visited innehåller genom att skriva dess namn och tryck på Enter\n\n\nCode\npercent_EUcountries_visited\n\n\n[1] 44.44444\n\n\n\n\nFunktioner i R\nTycker du att R visar onödigt många decimaler? Om du använder funktionen round() kan du bestämma hur många decimaler R skall visa. Lås oss uttrycka procentsatsen i objektet percent_EUcountries_visited med en decimal\n\n\nCode\nround(percent_EUcountries_visited, digits = 1)\n\n\n[1] 44.4\n\n\nEn funktion är en operation som är inbyggd i R. Funktionen har ett namn (i det här fallet round) och följs alltid av en parentes. I parentesen anger du objektet R skall göra något med, samt eventuella andra parametrar som måste anges. Om du använder dig av round() måste du ange hur många decimaler R skall avrunda till , digits = 1. Testa att ändra värdet föra tt få ett annat antal decimaler!\nOm du inte vet hur en funktion fungerar kan du alltid nå R’s hjälpfiler genom att skriva ett frågetecken följt av funktionens namn, och trycka Enter. Testa!\n?round\nVi testar några funktioner för att få summarisk statistik på ett antal värden, som vi sparar i ett objekt som vi kallar counts\n\n\nCode\ncounts <- c(3,6,5,8,4,6,2,4,6,4,5,3,9,10,2,5,7,6)\n\n\nLås oss beräkna medelvärdet av counts, det gör vi med funktionen mean()\n\n\nCode\nmean(counts)\n\n\n[1] 5.277778\n\n\nVad är standardavvikelsen? Vi använder funktionen sd()\n\n\nCode\nsd(counts)\n\n\n[1] 2.244092\n\n\nHur många värden har vi i vår variabel counts? Använd funktionen length()\n\n\nCode\nlength(counts)\n\n\n[1] 18\n\n\nVad är standardfelet (standard error, SE)? Standard error är standardavvikelsen delat med kvadratroten av antalet mätvärden. Vi har använt alla de funktionerna, så testa att själv skriva en kod för att beräkna standard error. Kör du fast finns koden nedan.\n\n\nCode\nsd(counts) / sqrt(length(counts))\n\n\n[1] 0.5289375\n\n\nNär vi gör statistik så använder vi hela tiden R´s olika funktioner för att läsa in data, göra grafer, göra statistiska test och ge oss resultaten av testen. Det är alla inbyggda statistiska funktioner som gör R till ett ledande språk för statistiska beräkningar, och ytterligare funktioner finns i de tusentals paket som man kan installera i R."
  },
  {
    "objectID": "tutorials/use-R/index.html#använda-scriptfiler",
    "href": "tutorials/use-R/index.html#använda-scriptfiler",
    "title": "Använda R, en introduktion",
    "section": "Använda scriptfiler",
    "text": "Använda scriptfiler\nHittils har du interagerat med R interaktivt, det vill säga vi har bett R att göra något, R har gjort det, vi har bett R att göra något nytt, R har gjort det också osv. Det påminner om ett samtal med en annan person.\nNackdelen med att arbeta interaktivt är samma som nackdelen med ett muntligt samtal. Dels är det svårt att minnas vad som sades när vi tänker tillbaka på det senare, och dessutom är det svårt att göra komplicerade uppgifter om man inte börjar skriva ned vad man gör.\nHur gör vi för att minnas vårt samtal med R, vad vi har gjort och vad vi har kommit fram till? Vi använder oss av scriptfiler!\n\nVad är en scriptfil?\nEn scriptfil är ett dokument med ändelsen *.R där du dokumenterar de kommandon du ger till R i en logisk ordning. Du kan dessutom lägga till kommentarer till ditt script där du förklarar vad du gjort (det kallas att annotera scriptet).\nEftersom R alltid ger samma svar på dina kommandon (såvida du inte ber R att göra något som involveras slumptal) så räcker det att du dokumenterar de kommandon du ger till R. Sedan kan du köra dina kommandon på nytt, och får då reda på svaret på nytt.\n\n\nFördelar med scriptfiler\n\nDu dokumenterar vad du gör, och kan återupprepa din analys i framtiden\nOm du skall göra en ny analys i ett nytt dataset, men med metoder du tidigare använt och dokumenterat i ett script, så kan du kopiera ditt befintliga script och enbart förändra det som behövs för ditt nya data. Du behöver inte börja om från början. Dina gamla script är därmed en guldgruva när du skall analysera nya data.\nDu kan enklare felsöka kod och utveckla analyser som sker i flera steg\nDu kan enkelt gå tillbaka och förändra något steg i en analys\n\nFör att summera: det finns inga nackdelar med att använda sig av scriptfiler istället för att köra R interaktivt. Enbart fördelar. De enda gångerna jag själv använder R interaktivt är när jag använder R som en miniräknare för vardagsproblem."
  },
  {
    "objectID": "tutorials/linear-regression/index.html#läs-in-data",
    "href": "tutorials/linear-regression/index.html#läs-in-data",
    "title": "Linjär regression",
    "section": "Läs in data",
    "text": "Läs in data\nVi vill undersöka reproduktionen hos en växt. Därför har vi mätt höjden på 20 plantor och vi har även räknat hur många frön varje planta har. Nu vill vi ta reda på om antalet frön beror på plantornas höjd.\nLadda ner följande fil plant_reproduction.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en mapp med ett lämpligt namn.\nFortsätt med att läsa in datasetet och ge det ett namn, i det här fallet kallar vi det plant_reproduction_data. En detalerad beskrivning i hur man läser in filer finns i vår tidigare tutorial Läsa in data i R.\nGlöm inte att dokumentera din kod i ett script, med kommentarer som förklarar vad du gör! Se vår tutorial om script om du behöver påminnelse om hur man skapar och använder script.\n\n\nCode\nplant_reproduction_data <- read.table(\"data/plant_reproduction.txt\",\n                           header=T,\n                           sep=\"\\t\",\n                           dec=\",\") \n\n\n<- betyder att vi sparar resultatet av funktionen (i det här fallet read.table() i ett objekt. Pilen pekar på objektet, och vi ger objektet ett namn, i det här fallet plant_reproduction_data.\nread.table är kommandot för att läsa in textfiler med ändelsen .txt\n\"data/plant_reproduction.txt\" är sökvägen till platsen där datafilen är sparad på din dator(data/), samt namnet på filen (plant_reproduction.txt).\nheader=Tbetyder att första raden i filen är kolumnernas rubriker, dvs inte värden.\nsep=T betyder att alla värden är separerade med TAB.\ndec=\",\" betyder att komma används som decimalavgränsare (ex. 1,32)."
  },
  {
    "objectID": "tutorials/linear-regression/index.html#inspektera-data",
    "href": "tutorials/linear-regression/index.html#inspektera-data",
    "title": "Linjär regression",
    "section": "Inspektera data",
    "text": "Inspektera data\nBörja med att titta på datans struktur med str().\n\n\nCode\nstr(plant_reproduction_data)\n\n\n'data.frame':   20 obs. of  2 variables:\n $ Seeds       : int  466 501 467 489 496 521 522 517 506 427 ...\n $ Plant_height: int  45 45 44 54 52 57 53 50 48 32 ...\n\n\n$ Seeds: int betyder att värderna i kolumnen Seeds är heltal (integers)\n$ Plant_height: int betyder att värderna i kolumnen Mass är heltal (integers)\nOm du har en kolumn som innehåller decimaltal skall det stå num. Om det istället står chr betyder det att datat har punkt som decimalavgränsare, medan du läste in det med komma som avgränsare (eller tvärtom) och R tror att det är text. Justera koden och läs in datat på nytt (se vår tidigare tutorial Läsa in data i R för justerad kod).\nVisa sedan de fem första raderna av ditt dataset med head() för att se att allt ser korrekt ut\n\n\nCode\nhead(plant_reproduction_data)\n\n\n  Seeds Plant_height\n1   466           45\n2   501           45\n3   467           44\n4   489           54\n5   496           52\n6   521           57\n\n\n\nVisualisera datat med en enkel graf\nFör att göra grafen måste vi bestämma oss vad som skall vara på x-axeln, och vad som skall vara på y-axeln. Vilket av följande påstående är mest logiskt?\n\nVäxtens storlek påverkar hur många frön den har\nAntalet frön en växt har påverkar dess storlek\n\nAlternativ A är det som är mest logiskt. Alltså är det antalet frön som beror av växtens storlek. Därför skall vi ha antalet frön (Seeds) på y-axeln, och växtens storlek (Plants_height) på x-axeln.\nVi gör en enkel graf med funktionen plot() och lägger sedan till en regressionslinje med funktionen abline(). Grafen är inte publikationsduglig men ger en snabb överblick av våra data. Vi går igenom hur man gör en publiceringsduglig graf i den avslutande delen av vår tutorial, under Publiceringsduglig figur.\n\n\nCode\nplot(Seeds ~ Plant_height, data = plant_reproduction_data)\nabline(lm(Seeds ~ Plant_height, data = plant_reproduction_data))\n\n\n\n\n\nHur tolkar du grafen? Verkar det som att plantans höjd påverkar antalet frön den har?"
  },
  {
    "objectID": "tutorials/linear-regression/index.html#statistisk-modellering",
    "href": "tutorials/linear-regression/index.html#statistisk-modellering",
    "title": "Linjär regression",
    "section": "Statistisk modellering",
    "text": "Statistisk modellering\nVi vill nu göra en regressionsanalys för att undersöka om vår responsvariabel (beroende variabel) Seeds beror av vår förklarande variabel (oberoende variabel) Plants_height.\nVi specificerar en linjär modell med hjälp av funktionen lm() och väljer att spara resultatet i ett objekt som vi kallar m.plant_reproduction. Jag föredrar att alla mina modeller (resultat av statistka test) har ett namn som börjar med m. för att jag skall veta vad som är dataset och vad som är modeller. Ge alltid dina modeller beskrivande namn.\n\n\nCode\nm.plant_reproduction<-lm(Seeds~Plant_height,\n                    data=plant_reproduction_data)\n\n\nI vår modell har vi vår responsvariabel (det vi har på y-axeln) till vänster om tilde-tecknet ~ och vår förklarande variabel till höger. data=plant_reproduction_data betyder att vi använder oss av datasetet vi tidigare döpt till plant_reproduction_data.\n\nStatistiska resultat\nVi börjar med en ANOVA-tabell, och använder funktionen anova()\n\n\nCode\nanova(m.plant_reproduction)\n\n\nAnalysis of Variance Table\n\nResponse: Seeds\n             Df Sum Sq Mean Sq F value    Pr(>F)    \nPlant_height  1  18361 18360.8  68.681 1.477e-07 ***\nResiduals    18   4812   267.3                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nVi får en ANOVA-tabell och kan inspektera resultatet. Vi ser att p-värdet (här kallat Pr(>F)) är mindre än 0.05, dvs Plant_height har en signifikant effekt på Seeds. R indikerar även att det är signifikant genom att lägga till en eller flera stjärnor *. När du rapporterar p-värden i skrift anger du p-värdet med tre decimaler, eller “p < 0.001” vid väldigt låga p-värden.\nÄr det en positiv eller negativ effekt av Plant_height påSeeds? För att veta det behöver vi ta fram skattningen av alla parametrar i modellen, dvs var x-axeln skär y-axeln, och linjens lutning. För det användervi oss av funktionen summary().\n\n\nCode\nsummary(m.plant_reproduction)\n\n\n\nCall:\nlm(formula = Seeds ~ Plant_height, data = plant_reproduction_data)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-28.376 -13.475   3.509  12.360  24.505 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  317.2300    22.2835  14.236 3.08e-11 ***\nPlant_height   3.7064     0.4472   8.287 1.48e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 16.35 on 18 degrees of freedom\nMultiple R-squared:  0.7923,    Adjusted R-squared:  0.7808 \nF-statistic: 68.68 on 1 and 18 DF,  p-value: 1.477e-07\n\n\nCoefficients ger oss fakta om koefficienterna. Jämför gärna med figuren ni gjorde ovan. (Intercept) är värdet på y-axeln när x-axeln är noll, dvs där regressionslinjen skär y-axeln. Vi ser att den skär y-axeln vid 317.2300 och att p-värdet (Pr(>|t|)) är 3.08e-11 det vill säga mindre än 0.05, dvs interceptet är signifikant skiljt från noll. Plant_height är lutningen på regressionslinjen. Den har lutningskoefficienten 3.7064 och eftersom den inte börjar med ett minustecken vet vi att det är ett positivt samband mellan Plants_height ochSeeds (plustecken skrivs aldrig ut)\nR-square beskriver hur mycket av variationen i datat som förklaras av din statistiska modell. Kan gå från 0 (ingenting förklaras) till 1 (allt förklaras). R ger dig två värden, nämlingen Multiple R-squared och Adjusted R-squared. Använd Adjusted R-squared eftersom den tar hänsyn till antal parametrar i modellen."
  },
  {
    "objectID": "tutorials/linear-regression/index.html#presentera-din-statistiska-analys",
    "href": "tutorials/linear-regression/index.html#presentera-din-statistiska-analys",
    "title": "Linjär regression",
    "section": "Presentera din statistiska analys",
    "text": "Presentera din statistiska analys\nAntalet frön ökad med ökad höjd hos växten (linjär regression, F = 68.681, d.f. = 1 och 18, p < 0.001, R2 = 0.78).\nMan kan uttrycka den meningen på många sätt, ett alternativ är:\nJu högre växten är, desto fler frön har den (linjär regression, F = 68.681, d.f. = 1 och 18, p < 0.001, R2 = 0.78)."
  },
  {
    "objectID": "tutorials/linear-regression/index.html#utvärdera-den-statistiska-modellen",
    "href": "tutorials/linear-regression/index.html#utvärdera-den-statistiska-modellen",
    "title": "Linjär regression",
    "section": "Utvärdera den statistiska modellen",
    "text": "Utvärdera den statistiska modellen\nVar modellen lämplig att använda för ditt dataset?\nVi utvärderar modellen genom diagnostiska grafer genom att använda funktionen plot() på vår statistiska modell.\n\n\nCode\nplot(m.plant_reproduction)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVi får fyra grafer att utvärdera, de två första är viktigast. Du kan behöva trycka upprepade gånger på ENTER för att se alla graferna (i R kommer de en och en).\nResiduals vs Fitted bör visa en hyfsat rak linje. Den visar hur mycket residualerna (skillnaden i y-led mellan varje värde av din response och regressionslinjen) avviker från regressionslinjen. Residualerna motsvaras av cirklar i grafen. Om du har ett mönster i avvikelserna så betyder det att en rak regressionslinje inte var en lämplig statistisk modell.\nNormal Q-Q visar om residualerna är normalfördelade. De bör följa den diagonala streckade linjen. Om de avviker på ett systematiskt sätt är residualerna inte perfekt normalfördelade, och vi kan behöva förändra modellen, exempelvis genom att transformera data.\nScale-Location illustrerar om variationen i datat är lika över alla värden. Om variationen ökar mycket åt höger (ett vanligt fall) så har vi större variation vid högre värden. Kan lösas genom att transformera data.\nResiduals vs Leverage används för att hitta extremvärden som har onormalt stor påverkan på regressionslinjen. Mönstret i grafen är inte intressant, vi letar efter värden som ligger utanför de grå linjerna, speciellt linjerna för 1. Man bör dubbelkolla sådana värden (outliers) och fundera på om de skall vara med i datasetet. Kanske analysera såväl med som utan extremvärderna?"
  },
  {
    "objectID": "tutorials/use-R/index.html#hur-ser-en-scriptfil-ut",
    "href": "tutorials/use-R/index.html#hur-ser-en-scriptfil-ut",
    "title": "Använda R, en introduktion",
    "section": "Hur ser en scriptfil ut?",
    "text": "Hur ser en scriptfil ut?\nVi börjar med att ladda ner en befintlig scriptfil: testscript.R (högerklicka, välj “spara länk som”) och spara den på lämpligt ställe på din hårddisk. Välj sedan file -> open document i R, eller file -> open file i RStudio. Scriptfilen öppnas nu som ett nytt fönster (i R) eller i den övra vänstra delen av programmet (i RStudio).\nLåt oss ta en titt på scriptet\n\n\n\n\n\n\nKommentarer (annoteringar)\nVi ser att den första raden börjar med en hashtag (#).\n# Det här är ett testscript där vi tittar på hur ett script fungerar\nInnebörden är att raden inte tolkas som kod, utan som en kommentar till din kod. En fil som bara innehåller kod men inga kommentarer är ganska obegriplig, även för dig själv när du återvänder till scriptet några dagar senare. Vi använder kommentarerna för att dokumentera:\n\nVad vi gör\nVarför vi gör det\n\nEn väldokumenterad scriptfil (kallas också en väl annoterad scriptfil) är enkel att återvända till för att återupprepa analyserna eller tillämpa dem på nya dataset. Använder man RStudio färgas kommentarerna automatiskt i en avvikande färg.\n\n\nKod i scriptfiler\nDen första raden som inte börjar med en # är raden som lyder: 1+1\nDet är en rad med kod. I vårt script har vi dokumenterat vår fråga till R “vad är 1+1?”. Men vi har ännu inget svar från R. Vi har dokumenterat frågan, men inte ställt frågan än. Vi måste köra den raden i scriptet för att R skall ge oss ett svar.\nI princip kan man markera raden, kopiera koden och klistra in i konsolen (ha det som backuplösning om du glömmer bort hur man gör), men det är mycket smidigare att göra följande:\nMarkera koden du vill köra och:\n\ntryck command + Enter (på Mac)\ntryck ctrl + r (i Windows)\n\nKör raden med koden 1+1 enligt instruktionen ovan:\n\n\nCode\n1+1\n\n\n[1] 2\n\n\nNär du kört raden så dyker den upp i kosnolen, och på raden under får du svaret från R.\n\n\nKör kod i rätt ordning\nDen raden kod vi körde innehåller inga objekt, så den kan köras oberoende av andra rader. Men testa att köra raden: studiemedel2025 - studiemedel2024\nFår du ett felmeddelande? Error: object 'studiemedel2025' not found\nDet betyder att du ber R att göra någonting med ett objekt, men R vet inte vad det är för objekt. Du har dokumenterat skapandet av objektet i ditt script några rader ovanför:\n\n\nCode\n# Skapa objekt med studiemedel för respektive år\nstudiemedel2024 <- 13156\nstudiemedel2025 <-13500\n\n\nDu måste först köra de raderna, så att R vet vad objekten studiemedel2024 och studiemedel2025 innehåller. Sedan kan du köra raden studiemedel2025 - studiemedel2024 på nytt. Då skall det fungera!\n\n\nCode\n# Beräkna höjningen i kronor\nstudiemedel2025 - studiemedel2024\n\n\n[1] 344"
  },
  {
    "objectID": "tutorials/use-R/index.html#skriv-ditt-första-script",
    "href": "tutorials/use-R/index.html#skriv-ditt-första-script",
    "title": "Använda R, en introduktion",
    "section": "Skriv ditt första script",
    "text": "Skriv ditt första script\nNu skall vi testa att skriva ett eget script! Vi börjar med att skapa en scriptfil genom att klicka oss fram i menyerna:\n\nR: välj FIle > New document\nRStudio: välj File > New file > R Script\n\nDin uppgift är följande: Skapa ett script som räknar ut hur många år en person fyller i år (till exempel hur många år du fyller i år). Använd vårt script om studiemedelshöjningen ovan som inspirationskälla och kommentera scriptet väl.\nFörsök själv, men kör du fast kan du tjuvkika på en möjlig lösning nedan (under Code).\n\n\nCode\n# Ett skript för att räkna ut hur många år en person fyller\n\n# Ange vilket år det är i år\nyear_now <- 2026\n\n# Ange när personen är född\nyear_born <- 1998\n\n# Beräkna hur många år personen fyller i år\n\nyear_now - year_born\n\n\n[1] 28\n\n\nGlöm inte att spara ditt script med ett passande namn på din hårddisk. I R måste du skriva in filändelsen .R när du sparar scriptet första gången, medan RStudio automatiskt lägger till den filändelsen."
  },
  {
    "objectID": "tutorials/t-test/index.html#publiceringsduglig-figur",
    "href": "tutorials/t-test/index.html#publiceringsduglig-figur",
    "title": "t-test",
    "section": "Publiceringsduglig figur",
    "text": "Publiceringsduglig figur\nVi avslutar med att göra en publiceringsduglig figur, och använder oss av paketet ggplot2. Om du inte sedan tidigare har paketet installerat så gör du det med koden install.packages(\"ggplot2\"). Innan du använder paketet behöver du läsa in det i din session i R genom funktionen library()\n\nFörst - en enkel plot med ggplot2\n\n\nCode\nlibrary(ggplot2)\n\nplot.nutrient.simple <- ggplot(nutrientdata, aes(x = Nutrient_level, y = Mass, fill = Nutrient_level)) +\n  stat_summary(geom = \"bar\", fun = mean, width = 0.4) +\n  stat_summary(geom = \"errorbar\", fun.data = mean_se, width = 0.1) +\n  theme_classic()\n\nplot.nutrient.simple\n\n\n\n\n\nVi går nu igenom koden för vår plot. Den är utspridd över flera rader, där varje rad avslutas med ett + för att R skall förstå att koden fortsätter på nästa rad.\nggplot(nutrientdata, aes(x = Nutrient_level, y = Mass, fill = Nutrient_level)) + betyder att vi använder oss av funktionen ggplot(), och det första vi anger är namnet på vårt dataset, som vi kallade nutrientdata.\naes() är en funktion inom ggplot, här anger vi estetiken (aes står för aestetics). Vi anger namnet på de variabler som skall vara på x-axeln respektive y-axeln med x = Nutrient_level, y = Mass och eftersom vi vill att de olika nivåerna av vår faktor på x-axeln skall få olika färg lägger vi till fill = Nutrient_level.\nstat_summary(geom = \"bar\", fun = mean, width = 0.4) + betuder att vi vill beräkna summarisk statistik från vårt dataset och visa det med hjälp av funktionen stat_summary(). geom = \"bar\" betyder att vi vill göra ett stapeldiagram (\"bar\" står för barplot). fun = mean betyder att staplarna skall baseras på medelvärdet, och width = 0.4 betyder att de skall ha en relativ bredd på 0.4 (testa att ändra, men för breda staplar ser ofta fult ut)\nstat_summary(geom = \"errorbar\", fun.data = mean_se, width = 0.1) + Den här raden är också en stat_summary(), men här lägger vi till ett annat element till grafen. geom = \"errorbar\" betyder att vi nu vill lägga till felstaplar (errorbars),fun.data = mean_se betyder att felstaplarna skall representera standard error och vi anger deras bredd med width = 0.1, Felstaplar bör vara smalare än staplarna.\ntheme_classic() är ett tema för grafer. Det är det temat som gör att graferna ser ut så som vi förväntar oss i naturvetenskapliga publikationer (vit bakgrund, inga stödlinjer, ren design). Notera att det är sista raden i vårt script, så den skall inte avslutas med plustecken.\n\n\nModifiera din plot så den blir publiceringsduglig\nVår enkla figur där vi enbart anger dataset och våra variablar blev ju inte alls tokig, men vi kan förbättra den. Vi skulle vilja fixa till följande:\n\nVi vill att det skall stå Nutrient level och inte Nutrient_level på x-axeln, fixas med xlab()\nVi vill ange att massan är mätt i gram, fixas med ylab()\nVi vill välja andra färger, och dessutom skall det inte stå Nutrient_level i vår legend. Fixas med scale_fill_manual()\n\n\n\nCode\nlibrary(ggplot2)\n\nplot.nutrient <- ggplot(nutrientdata, aes(x = Nutrient_level, y = Mass, fill = Nutrient_level)) +\n  stat_summary(geom = \"bar\", fun = mean, width = 0.4) +\n  stat_summary(geom = \"errorbar\", fun.data = mean_se, width = 0.1) +\n  xlab(\"Nutrient level\")+\n  ylab(\"Mass (g)\")+\n  scale_fill_manual(name = \"Nutrient level\", values = c(\"High\" = \"darkgreen\", \"Low\" = \"palegreen\"))+\n  theme_classic()\n\nplot.nutrient\n\n\n\n\n\nOm du vill se en lista med namn på alla färger som R innehåller så kör du koden colors(). Om du vill ha en specifik färg (och vet vad du gör) så kan du även ta fram färgens hexidecimala kod i ett bildbehandlingsprogram och ange den istället."
  },
  {
    "objectID": "tutorials/linear-regression/index.html#publiceringsduglig-figur",
    "href": "tutorials/linear-regression/index.html#publiceringsduglig-figur",
    "title": "Linjär regression",
    "section": "Publiceringsduglig figur",
    "text": "Publiceringsduglig figur\nVi avslutar med att göra en publiceringsduglig figur, och använder oss av paketet ggplot2. Om du inte sedan tidigare har paketet installerat så gör du det med koden install.packages(\"ggplot2\"). Innan du använder paketet behöver du läsa in det i din session i R genom funktionen library()\n\nFörst - en enkel plot med ggplot2\n\n\nCode\nlibrary(ggplot2)\n\nplot.plant_reproduction.simple <- ggplot(plant_reproduction_data, aes(x = Plant_height, y = Seeds)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  theme_classic()\n\nplot.plant_reproduction.simple\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nVi går nu igenom koden för vår plot. Den är utspridd över flera rader, där varje rad avslutas med ett + för att R skall förstå att koden fortsätter på nästa rad.\nggplot(plant_reproduction_data, aes(x = Plant_height, y = Seeds)) + betyder att vi använder oss av funktionen ggplot(), och det första vi anger är namnet på vårt dataset, som vi kallade plant_reproduction_data.\naes() är en funktion inom ggplot, här anger vi estetiken (aes står för aestetics). Vi anger namnet på de variabler som skall vara på x-axeln respektive y-axeln med x = Plant_height, y = Seeds.\ngeom_point() + betuder att vi vill att varje datapunkt skall bli en punkt\ngeom_smooth(method = \"lm\", se = FALSE) + betyder att vi lägger till en linjär regressionslinje med method = \"lm\" och vi vill inte ha standardavvikelser, vilket vi anger med se = FALSE. Man brukar inte ha med det i grafer med regressioner. Vill du ändå ha osäkerheten i grafen kan du ersätta FALSE med TRUE.\ntheme_classic() är ett tema för grafer. Det är det temat som gör att graferna ser ut så som vi förväntar oss i naturvetenskapliga publikationer (vit bakgrund, inga stödlinjer, ren design). Notera att det är sista raden i vårt script, så den skall inte avslutas med plustecken.\n\n\nPubliceringsbar figur\nDen blev helt ok, men vi kan förbättra den.\n\nVi vill att det skall stå “Plant height (cm)” på x-axeln, fixas med xlab()\nVi vill att det skall stå “Number of seeds” på y-axeln, fixas med ylab()\nVi vill välja blå punkter, och vi vill att de skall vara lite större,fixas med cex och color inom geom_point()\nVi vill att regressionslinjen skall vara svart och som punkter, fixas med color och lty (står för line type) i geom_smooth()\n\n\n\nCode\nlibrary(ggplot2)\n\nplot.plant_reproduction <- ggplot(plant_reproduction_data, aes(x = Plant_height, y = Seeds)) +\n  geom_point(cex = 3, colour = \"blue\") +\n  geom_smooth(method = \"lm\", se = FALSE, lty = 3, color = \"black\") +\n  xlab(\"Plant height (cm)\")+\n  ylab(\"Number of seeds\")+\n  theme_classic()\n\nplot.plant_reproduction\n\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "tutorials/correlation/index.html",
    "href": "tutorials/correlation/index.html",
    "title": "Korrelationer",
    "section": "",
    "text": "En korrelationsanalys används om man vill undersöka om två kontinuerliga variabler samvarierar, men till skillnad från vid regressionsanalys så har man nu ingen hypotes om att det finns ett orsakssamband mellan dem. Det spelar alltså ingen roll vilken variabel som är på y-axeln och vilken som är på x-axeln.\nKorrelationer används ofta om man vill undersöka mönster snarare än att testa hypoteser."
  },
  {
    "objectID": "tutorials/correlation/index.html#läs-in-data",
    "href": "tutorials/correlation/index.html#läs-in-data",
    "title": "Korrelationer",
    "section": "Läs in data",
    "text": "Läs in data\nVi vill undersöka om det finns en korrelation mellan diametern och höjden på ett antal trädindivider av samma art.\nLadda ner följande fil trees.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en mapp med ett lämpligt namn.\nFortsätt med att läsa in ett dataset och ge det ett namn, i det här fallet kallar vi det tree.data. En detaljerad beskrivning i hur man läser in filer finns i vår tidigare tutorial Läsa in data i R.\nGlöm inte att dokumentera din kod i ett script, med kommentarer som förklarar vad du gör! Se vår tutorial om script om du behöver påminnelse om hur man skapar och använder script.\n\n\nCode\ntree.data<-read.table(\"data/trees.txt\",\n                      header = T, sep = \"\\t\", dec = \",\")"
  },
  {
    "objectID": "tutorials/correlation/index.html#inspektera-data",
    "href": "tutorials/correlation/index.html#inspektera-data",
    "title": "Korrelationer",
    "section": "Inspektera data",
    "text": "Inspektera data\nBörja med att titta på datans struktur med str().\n\n\nCode\nstr(tree.data)\n\n\n'data.frame':   50 obs. of  2 variables:\n $ diameter: num  1.49 1.64 1.06 1.77 1.01 ...\n $ height  : num  14.5 20.9 16.1 22.4 14.7 ...\n\n\n$ diameter: num betyder att värderna i kolumnen diameter är decimaltal (numeric)\n$ height: num betyder att värderna i kolumnen height är decimaltal (numeric)\nVisa sedan de fem första raderna av ditt dataset med head() för att se att allt ser korrekt ut\n\n\nCode\nhead(tree.data)\n\n\n  diameter   height\n1 1.485763 14.53057\n2 1.635011 20.94121\n3 1.059496 16.10711\n4 1.773606 22.39200\n5 1.012026 14.73974\n6 1.905565 17.44242"
  },
  {
    "objectID": "tutorials/correlation/index.html#visualisera-datat-med-en-enkel-graf",
    "href": "tutorials/correlation/index.html#visualisera-datat-med-en-enkel-graf",
    "title": "Korrelationer",
    "section": "Visualisera datat med en enkel graf",
    "text": "Visualisera datat med en enkel graf\nVi gör en graf med plot(). Eftersom vi inte har någon hypotes om ett orsakssamband mellan våra variabler spelar det ingen roll vilken vi har på vilken axel (hade vi haft en hypotes om ett orsakssamband så hade vi gjort en regression istället). Av samma anledning har vi inte heller någon regressionslinje i grafen när vi vill undersöka en korrelation.\n\n\nCode\nplot(height ~ diameter, data = tree.data)\n\n\n\n\n\nSer det ut som att diameter och height är korrelerade med varandra? Är det i så fall en positiv eller negativ korrelation?"
  },
  {
    "objectID": "tutorials/correlation/index.html#statistisk-modellering",
    "href": "tutorials/correlation/index.html#statistisk-modellering",
    "title": "Korrelationer",
    "section": "Statistisk modellering",
    "text": "Statistisk modellering\nVi vill nu göra en korrelationsanalys mellan våra två variablar.\nVi använder oss av funktionen cor.test() och väljer att spara resultatet i ett objekt som vi kallar m.trees.\n\n\nCode\nm.trees <- cor.test(tree.data$diameter, tree.data$height, method = \"p\")\n\n\nNotera att korrelationstesten kräver att man anger modellen på ett annat sätt än i andra metoder. Istället för att ange våra variablar och sedan datasetet, måste vi ange dataset och variabel tillsammans, genom koden dataset$variabel. Till vänster om dollartecknet är datasetets namn, till höger är variabelnamnet.\nmethod=\"p\"specificerar metoden vi skall använda oss av för att göra korrelationen. p står för Pearson och används om data är normalfördelade.\nVi skriver modellnamnet och kör koden\n\n\nCode\nm.trees\n\n\n\n    Pearson's product-moment correlation\n\ndata:  tree.data$diameter and tree.data$height\nt = 2.6562, df = 48, p-value = 0.0107\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.08844295 0.57866607\nsample estimates:\n     cor \n0.357978 \n\n\nVi kan inspektera resultatet. Vi ser att p-värdet är mindre än 0.05, dvs vi har en signifikant korrelation. Vi får även teststatistika i form av t-värde och frihetsgrader (df).\nVi får även ett värde på korrelations-coefficienten cor (vanligtvis kallad r ), som är 0.36. r kan gå mellan -1 och +1, där -1 representerar en perfekt negativ korrelation, +1 representerar en perfekt positiv korrelation och 0 betyder att en korrelation saknas. Vi har en positiv korrelation. Stämmer det när du inspekterar grafen ovan?\nNotera att r (i korrelationsanalyser) och r2 (i regressioner) inte är samma sak. r skall inte heller tolkas som en regressionskoefficient (som ju kan anta hur positiva eller negativa värden som helst, medan r alltid ligger mellan -1 och +1)."
  },
  {
    "objectID": "tutorials/correlation/index.html#presentera-din-statistiska-analys",
    "href": "tutorials/correlation/index.html#presentera-din-statistiska-analys",
    "title": "Korrelationer",
    "section": "Presentera din statistiska analys",
    "text": "Presentera din statistiska analys\nTrädens höjd är positivt korrelerad med diametern (t = 2,66, df = 48, p = 0,011, r = 0,38).\nEftersom vi inte har någon hypotes om orsakssamband (det är därför vi gör en korrelation och inte en regression) kan man även uttrycka samma mening med variablarna omkastade:\nTrädens diameter är positivt korrelerad med höjden (t = 2,66, df = 48, p = 0,011, r = 0,38)."
  },
  {
    "objectID": "tutorials/correlation/index.html#utvärdera-modellen",
    "href": "tutorials/correlation/index.html#utvärdera-modellen",
    "title": "Korrelationer",
    "section": "Utvärdera modellen",
    "text": "Utvärdera modellen\nDet finns ingen implementering av plot(modellnamn)för korrelationstest, så vi får istället undersöka om våra data var normalfördelade. Det kan göras grafiskt eller med ett test. Om data inte verkar vara normalfördelade använder du method = \"s\" i modellen (det är en mindre kraftfull metod som dock kan hantera icke-normalfördelade data).\n\nGrafiskt - histogram\nHistogram har värdet hos din variabel på x-axeln, och frekvens (antalet observationer) på y-axeln. En normalfördelning har flest observationer av värden runt medelvärdet, och antalet observationer minskar sedan symmetriskt om man går mot extremare värden.\n\n\nCode\nhist(tree.data$diameter)\n\n\n\n\n\n\n\nCode\nhist(tree.data$height)\n\n\n\n\n\nDet ser normalfördelat ut. Om det blir för få staplar kan man ange antal staplar med koden breaks =. Man får testa sig fram till ett lämpligt antal breaks.\n\n\nCode\nhist(tree.data$height, breaks = 14)"
  },
  {
    "objectID": "tutorials/chi2/index.html",
    "href": "tutorials/chi2/index.html",
    "title": "\\(\\chi\\) 2 test (chi-2)",
    "section": "",
    "text": "chi2-testet (eller \\(\\chi\\) 2 som det egentligen skall skrivas med grekiska bokstäver) är ett test för räknedata (count data), där du räknat någonting snarare än att du mätt det. Det kan exemelvis vara antalet individer eller antalet arter.\n\\(\\chi\\) 2 testet används för att undersöka om två kategoriska variabler påverkar antalet i de olika kategorierna. De kategoriska variablerna kan till exempel vara kön (hona/hane), stadium (juvenil/adult), art eller någon behandling eller annat som kan kategorisera din data.\nEn förutsättning för \\(\\chi\\) 2 - testet är att dataseten skall vara relativt stora. Om du har mindre än fem som den förväntade frekvensen i någon av dina kategorier bör du istället använda dig av Fishers exakta test (se beskrivning nedan)."
  },
  {
    "objectID": "tutorials/chi2/index.html#läs-in-data",
    "href": "tutorials/chi2/index.html#läs-in-data",
    "title": "\\(\\chi\\) 2 test (chi-2)",
    "section": "Läs in data",
    "text": "Läs in data\nVi har inventerat sanddyner i två succesionsstadier (unga eller gamla) och räknat antal individer av de två gräsarterna sandrör (Ammophila arenaria) och borsttåtel (Corynephorus canescens). Vi vill veta om antalet gräs av de två arterna skiljer sig från en slumpmässig fördelning mellan de två successionsstadierna.\nLadda ner följande fil dunegrass.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en mapp med ett lämpligt namn.\nFortsätt med att läsa in datasetet och ge det ett namn, i det här fallet kallar vi det dunegrass_data. En detalerad beskrivning i hur man läser in filer finns i vår tidigare tutorial Läsa in data i R.\nGlöm inte att dokumentera din kod i ett script, med kommentarer som förklarar vad du gör! Se vår tutorial om script om du behöver påminnelse om hur man skapar och använder script.\n\n\nCode\ndunegrass_data <- read.table(\"data/dunegrass.txt\",\n                           header=T,\n                           sep=\"\\t\",\n                           dec=\",\")"
  },
  {
    "objectID": "tutorials/chi2/index.html#inspektera-data",
    "href": "tutorials/chi2/index.html#inspektera-data",
    "title": "\\(\\chi\\) 2 test (chi-2)",
    "section": "Inspektera data",
    "text": "Inspektera data\nBörja med att titta på datans struktur med str().\n\n\nCode\nstr(dunegrass_data)\n\n\n'data.frame':   4 obs. of  3 variables:\n $ Species : chr  \"Ammophila.arenaria\" \"Ammophila.arenaria\" \"Corynephorus.canescens\" \"Corynephorus.canescens\"\n $ Dune.age: chr  \"young\" \"old\" \"young\" \"old\"\n $ Counts  : int  57 12 17 43\n\n\n$ Species: chr betyder att värderna i kolumnen Species är bokstäver (characters)\n$ Dune.age: chr betyder att värderna i kolumnen Dune.age är bokstäver (characters)\n$ Counts: int betyder att värderna i kolumnen Counts är heltal (integers)\nVisa sedan de fem första raderna av ditt dataset med head() för att se att allt ser korrekt ut\n\n\nCode\nhead(dunegrass_data)\n\n\n                 Species Dune.age Counts\n1     Ammophila.arenaria    young     57\n2     Ammophila.arenaria      old     12\n3 Corynephorus.canescens    young     17\n4 Corynephorus.canescens      old     43"
  },
  {
    "objectID": "tutorials/chi2/index.html#statistisk-modell",
    "href": "tutorials/chi2/index.html#statistisk-modell",
    "title": "\\(\\chi\\) 2 test (chi-2)",
    "section": "Statistisk modell",
    "text": "Statistisk modell\n\nSkapa en korstabell\nFör att kunna analysera data med ett \\(\\chi\\) 2 test måste datat vara i form av en korstabell (contingency table) vilket är en matris med två rader och två kolumner. Vi kan göra om vårt dataset dunegrass_data till en korstabell med funktionen xtabs(). Vi sparar vår korstabell i ett nytt objekt som vi kallar dunegrass_cont_table\n\n\nCode\ndunegrass_cont_table <- xtabs(Counts ~ Species + Dune.age, data = dunegrass_data)\n\ndunegrass_cont_table\n\n\n                        Dune.age\nSpecies                  old young\n  Ammophila.arenaria      12    57\n  Corynephorus.canescens  43    17\n\n\n\n\nGör ett \\(\\chi\\) 2 test\nNu har vi en korstabell och kan göra ett \\(\\chi\\) 2 test. Vi använder oss av funktionen chisq.test() och sparar resultatet i ett objekt vi kallar m.dunegrass\n\n\nCode\nm.dunegrass <- chisq.test(dunegrass_cont_table)\n\n\nVi tittar på resultatet genom att skriva in m.dunegrass och köra det\n\n\nCode\nm.dunegrass\n\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  dunegrass_cont_table\nX-squared = 36.467, df = 1, p-value = 1.553e-09\n\n\nVi får nu vår teststatistika med \\(\\chi\\) 2 -värde (X-squared), frihetsgrader (df) och vårt p-värde (p-value). Vi ser att p-värdet är mindre än 0.05, vilket betyder att fördelningen av antal individer av de två arterna inte är slumpmässigt fördelat mellan habitaten.\nViktigt att notera är att \\(\\chi\\) 2 testet testar om de observerande frekvenserna skiljs från de förväntade frekvenserna. Notera att de förväntade frekvenserna inte behöver vara att det är 25% i varje kategori, det kan ju vara så att en av arterna generellt är mycket vanligare än den andra, och/eller att en av miljöerna innehåller totalt sett fler individer.\nVi kan se det förväntade antalet i varje kategori genom att ange $expected efter modellnamnet.\n\n\nCode\nm.dunegrass$expected\n\n\n                        Dune.age\nSpecies                      old   young\n  Ammophila.arenaria     29.4186 39.5814\n  Corynephorus.canescens 25.5814 34.4186\n\n\nVi kan jämföra det med våra observerade frekvenser, som vi får fram genom att ange $observed efter modellnamnet.\n\n\nCode\nm.dunegrass$observed\n\n\n                        Dune.age\nSpecies                  old young\n  Ammophila.arenaria      12    57\n  Corynephorus.canescens  43    17\n\n\nVi ser att det är fler observerade Corynephorus.canescens i gamla dyner är förväntat, och fler Ammophila.arenaria i unga dyner än förväntat."
  },
  {
    "objectID": "tutorials/chi2/index.html#visualisera-data",
    "href": "tutorials/chi2/index.html#visualisera-data",
    "title": "\\(\\chi\\) 2 test (chi-2)",
    "section": "Visualisera data",
    "text": "Visualisera data\nVi visualiserar data med ett stapeldiagram, och använder oss paketet ggplot2. Om du inte sedan tidigare har paketet installerat så gör du det med koden install.packages(\"ggplot2\"). Innan du använder paketet behöver du läsa in det i din session i R genom funktionen library()\n\n\nCode\nlibrary(ggplot2)\n\nplot.dunegrass <- ggplot(dunegrass_data, aes(x = Dune.age, y = Counts, fill = Species)) +\n  stat_summary(geom = \"bar\", fun = \"identity\", position = \"dodge\", width = 0.4) +\n  theme_classic()\n\nplot.dunegrass\n\n\n\n\n\nGrafen påminner om den vi gjort för t-test, så vi fokuserar på skillnaderna.\nI första raden under aes() anger namnet på de variabler som skall vara på x-axeln respektive y-axeln med x = Dune.age, y = Counts. Vi vill att de olika nivåerna av vår faktor Species skall ha olika färg, därför lägger vi till fill = Species.\nRaden stat_summary(geom = \"bar\", fun = \"identity\", position = \"dodge\", width = 0.4) + har några förändringar från när vi gjorde en graf baserat på medelvärden. Nu skall vi inte beräkna ett medelvärde för höjden på staplarna, utan vi vill använda de värden som finns i Counts. Därför anger vi fun = \"identity\". Vi vill också att de två arterna skall ligga bredvid varandra (parade staplar) och inte ovanpå varandra, därför anger vi position = \"dodge\".\nVi kan senare modifiera vår plot så den blir färdig för publikation, se avsnittet Modifiera din plot så den blir publiceringsduglig."
  },
  {
    "objectID": "tutorials/chi2/index.html#modifiera-din-plot-så-den-blir-publiceringsduglig",
    "href": "tutorials/chi2/index.html#modifiera-din-plot-så-den-blir-publiceringsduglig",
    "title": "\\(\\chi\\) 2 test (chi-2)",
    "section": "Modifiera din plot så den blir publiceringsduglig",
    "text": "Modifiera din plot så den blir publiceringsduglig\nVår enkla figur där vi enbart anger dataset och våra variablar blev ok, men vi kan förbättra den. Vi skulle vilja fixa till följande:\n\nVi vill att det skall stå “Dune age” och inte Dune.age på x-axeln, fixas med xlab()\nVi vill ange att responsvariabeln är “Number of plants”, fixas med ylab()\nVi vill välja andra färger (gärna färger som motsvarar de två gräsens färg när man ser dem i fält), och vi vill att artnamnen skall vara kursiverade och utan punkt i vår legend. Fixas med scale_fill_manual()\n\n\n\nCode\nlibrary(ggplot2)\n\nplot.dunegrass.final <- ggplot(dunegrass_data, aes(x = Dune.age, y = Counts, fill = Species)) +\n  stat_summary(geom = \"bar\", fun = \"identity\", position = \"dodge\", width = 0.4) +\n  xlab(\"Dune age\")+\n  ylab(\"Number of plants\")+\n   scale_fill_manual(\n    values = c(\n      \"Ammophila.arenaria\" = \"beige\",\n      \"Corynephorus.canescens\" = \"darkgreen\"\n    ),\n    labels = c(\n      expression(italic(\"Ammophila arenaria\")),\n      expression(italic(\"Corynephorus canescens\"))\n    )\n  ) +\n  theme_classic() +\n  theme(\n    legend.text = element_text(hjust = 0)\n  )\n\nplot.dunegrass.final\n\n\n\n\n\nVåra justeringar i xlab() och ylab() är självförklarande, och vi har tidigare gått igeom dem under vår tutorial om t-test.\nVi gör en hel del justeringar i scale_fill_manual(). På samma sätt som tidigare anger vi vilka nivåer av vår grupperande faktor (se vilken det är i aes()) som skall ha vilken färg. Det anger vi med koden\nvalues = c(       \"Ammophila.arenaria\" = \"beige\",       \"Corynephorus.canescens\" = \"darkgreen\"     ),\nFör att få artnamnen kursiverade är det en ny kod vi får lära oss (vi är fortfarande inom funktionen scale_fill_manual()). Vi använder oss av expression() för att modifiera texten Det är väldigt vanligt att behöva göra det, vi biologer vill ofta ha med latinska artnamn i våra grafer, och de skall vara kursiverade!\nlabels = c(       expression(italic(\"Ammophila arenaria\")),       expression(italic(\"Corynephorus canescens\"))     )\nitalic() står för kursiv text, och eftersom vi inte vill ha någon punkt mellan släkte och artepitet (dvs Ammophila arenaria och inte Ammophila.arenaria) så skriver vi manuellt in vad som skall stå i vår legend.\nNu borde grafens kod vara klar, men om du kör den så upptäcker du att våra latinska artnamn blir centrerade och inte vänsterjusterade! Det är expression() som är boven i dramat, den har som grundinställning att centrera allt den gör. För att fixa det måste vi ställa in vårat tema så att det ignorerar andra textjusteringar och alltid har vänsterjusterad text i legenderna. Vi gör det genom att lägga till en sista rad kod med funktionen theme()\ntheme(     legend.text = element_text(hjust = 0)   )\nhjust = 0 betyder vänsterjustering. Notera att eftersom vår tidigare sista rad i scriptet theme_classic() inte längre är sista rad behöver vi lägga till ett plustecken + sist i den raden så att R förstår att scriptet fortsätter nedanför."
  },
  {
    "objectID": "tutorials/chi2/index.html#presentera-dina-statistiska-resultat",
    "href": "tutorials/chi2/index.html#presentera-dina-statistiska-resultat",
    "title": "\\(\\chi\\) 2 test (chi-2)",
    "section": "Presentera dina statistiska resultat",
    "text": "Presentera dina statistiska resultat\nDe två gräsarterna är inte slumpmässigt fördelade mellan sanddyner av olika ålder, utan Ammophila arenaria förekommer i högst antal i unga sanddyner, medan Corynephorus canescens är vanligast i gamla sanddyner (\\(\\chi\\) 2 test, \\(\\chi\\) 2 = 36.47, df = 1, p < 0.001)."
  },
  {
    "objectID": "tutorials/chi2/index.html#utvärdera-din-modell",
    "href": "tutorials/chi2/index.html#utvärdera-din-modell",
    "title": "\\(\\chi\\) 2 test (chi-2)",
    "section": "Utvärdera din modell",
    "text": "Utvärdera din modell\nDet viktiga för att få göra ett \\(\\chi\\) 2 test är att ingen av de förväntade frekvenserna är lägre än 5. Du ser de förväntade frekvenserna genom att ange $expected efter modellnamnet.\n\n\nCode\nm.dunegrass$expected\n\n\n                        Dune.age\nSpecies                      old   young\n  Ammophila.arenaria     29.4186 39.5814\n  Corynephorus.canescens 25.5814 34.4186"
  },
  {
    "objectID": "tutorials/anova/index.html",
    "href": "tutorials/anova/index.html",
    "title": "Envägs ANOVA",
    "section": "",
    "text": "Anova står för Analysis of Variance och är en samling statistiska metoder som analyserar hur den totala variansen i datat fördelar sig inom och mellan grupper. Metoden är mycket flexibel och kan användas för såväl en som flera faktorer, och de kan vara såväl diskreta (med flera nivåer) som kontinuerliga. Vi kommer att börja med envägs-ANOVA som hanterar en faktor.\nEnvägs ANOVA används för att undersöka om två eller flera nivåer av en faktor skiljer sig i medelvärde. För två nivåer (exempelvis hur två arter skiljer sig i storlek) är modellen en direkt ersättning för t-testet, men till skillnad från t-testet kan man testa fler nivåer (exempelvis hur 3+ arter skiljer sig i storlek).\nEn ANOVA förutsätter följande\nNotera att det är residualerna och inte rådatat som skall vara normalfördelat."
  },
  {
    "objectID": "tutorials/anova/index.html#läs-in-data",
    "href": "tutorials/anova/index.html#läs-in-data",
    "title": "Envägs ANOVA",
    "section": "Läs in data",
    "text": "Läs in data\nVi har elfiskat i tre bäckar, och vill undersöka om öringarnas storlek skiljer sig åt mellan de tre bäckarna.\nLadda ner följande fil trout_stream.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en mapp med ett lämpligt namn.\nFortsätt med att läsa in datasetet och ge det ett namn, i det här fallet kallar vi det trout_data En detalerad beskrivning i hur man läser in filer finns i vår tidigare tutorial Läsa in data i R.\nGlöm inte att dokumentera din kod i ett script, med kommentarer som förklarar vad du gör! Se vår tutorial om script om du behöver påminnelse om hur man skapar och använder script.\n\n\nCode\ntrout_data <- read.table(\"data/trout_stream.txt\",\n                           header=T,\n                           sep=\"\\t\",\n                           dec=\",\")"
  },
  {
    "objectID": "tutorials/anova/index.html#inspektera-data",
    "href": "tutorials/anova/index.html#inspektera-data",
    "title": "Envägs ANOVA",
    "section": "Inspektera data",
    "text": "Inspektera data\nBörja med att titta på datans struktur med str().\n\n\nCode\nstr(trout_data)\n\n\n'data.frame':   18 obs. of  2 variables:\n $ Stream      : chr  \"Klevabacken\" \"Klevabacken\" \"Klevabacken\" \"Klevabacken\" ...\n $ Trout.length: num  231 136 176 158 190 ...\n\n\n$ Stream: chr betyder att värderna i kolumnen Stream är karaktärer dvs text och inte siffror.\n$ Trout.length: num betyder att värderna i kolumnen Trout.length är decimaltal\nVisa sedan de fem första raderna av ditt dataset med head() för att se att allt ser korrekt ut\n\n\nCode\nhead(trout_data)\n\n\n       Stream Trout.length\n1 Klevabacken        231.4\n2 Klevabacken        135.9\n3 Klevabacken        176.0\n4 Klevabacken        158.4\n5 Klevabacken        189.7\n6 Klevabacken        216.0"
  },
  {
    "objectID": "tutorials/anova/index.html#visualisera-datat-med-en-enkel-graf",
    "href": "tutorials/anova/index.html#visualisera-datat-med-en-enkel-graf",
    "title": "Envägs ANOVA",
    "section": "Visualisera datat med en enkel graf",
    "text": "Visualisera datat med en enkel graf\nVi gör en enkel graf med boxplot()\n\n\nCode\nboxplot(Trout.length~Stream, \n        data = trout_data)\n\n\n\n\n\nDen grå boxen innehåller de mittersta 50% av värderna i gruppen, och den horisontella linjen i mitten visar medianvärdet. Felstaplarna visar området som de 25% lägsta och 25% högsta värderna ligger i.\nObservera: en boxplot är INTE ett statistiskt test, och det motsvarar inte medelvärden och varians/standard error. Använd det enbart för snabb inspektion av data, inte för publicering. Vi går igenom hur man gör en publiceringsduglig graf i den avslutande delen av vår tutorial, under Publiceringsduglig figur\nHur tolkar du grafen? Skiljer sig öringarna från de tre bäckarna åt i storlek, eller är det någon bäck som avviker från de andra?"
  },
  {
    "objectID": "tutorials/anova/index.html#statistisk-modellering",
    "href": "tutorials/anova/index.html#statistisk-modellering",
    "title": "Envägs ANOVA",
    "section": "Statistisk modellering",
    "text": "Statistisk modellering\nVi vill nu göra en envägs ANOVA för att undersöka om vår responsvariabel (beroende variabel) Trout.length beror av vår förklarande variabel (oberoende variabel) Stream, med andra ord om öringarnas storlek är olika i de olika bäckarna.\nVi specificerar en modell med hjälp av funktionen lm() som står för linjär modell och väljer att spara resultatet i ett objekt som vi kallar m.trout. Jag föredrar att alla mina modeller (resultat av statistka test) har ett namn som börjar med m. för att jag skall veta vad som är dataset och vad som är modeller. Ge alltid dina modeller beskrivande namn.\n\n\nCode\nm.trout <- lm (Trout.length ~ Stream,\n                    data = trout_data)\n\n\nI vår modell har vi vår responsvariabel (det vi har på y-axeln) till vänster om tilde-tecknet ~ och vår förklarande variabel till höger. data = trout_data betyder att vi använder oss av datasetet vi tidigare döpt till trout_data.\n\nStatistiska resultat - övergripande modell\nVi tittar på resultatet genom att använda funktionen anova() med modellns namn.\n\n\nCode\nanova(m.trout)\n\n\nAnalysis of Variance Table\n\nResponse: Trout.length\n          Df Sum Sq Mean Sq F value    Pr(>F)    \nStream     2  31727 15863.7  14.353 0.0003286 ***\nResiduals 15  16579  1105.3                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nVi kan nu inspektera resultatet. Vi får teststatistika (F-värde) samt två frihetsgrader (Df) och ett p-värde (kallas Pr(>F)).\nEftersom vårt p-värde är mindre än 0.05 kan vi dra slutsatsen att öringarnas storlek är skiljt mellan bäckarna.\nHade vi bara haft två nivåer av vår faktor (dvs två bäckar) så hade vi nu vetat att öringarna i de två bäckarna skiljer sig i storlek. Men vi har ju tre bäckar! Skiljer sig öringarna i storlek mellan alla bäckar, eller bara mellan några? Det vet vi inte än, vi måste gå vidare för att testa det, vilket vi gör med ett post-hoc test.\n\n\nPost-hoc\nOm din övergripande faktor (Stream i det här exemplet) är signifikant skall man fortsätta med ett post-hoc test. Post-hoc testet gör som standard parvisa jämförelser mellan nivåerna av din signifikanta faktor, och justerar p-värderna för multipla tester (gör man många tester så är det sannolikt att man får en signifikant jämförelse av ren slump).\nDet finns många olika post-hoc tester, men en mycket vanlig är den som kallas Tukey’s HSD ( där HSD står för Honest Significant Difference), den används generellt när man vill jämföra alla olika nivåer av din signifikanta faktor (dvs jämföra alla bäckar) och har lika antal replikat i de olika nivåerna (vi har provtagit samma antal öringar i varje bäck).\nFör att kunna göra Tukey’s HSD använder vi oss av paketet emmeans. Om du inte sedan tidigare har paketet installerat så gör du det med koden install.packages(\"emmeans\"). Innan du använder paketet behöver du läsa in det i din session i R genom funktionen library()\nVi använder oss av funktionen emmeans() i paketet med samma namn.\n\n\nCode\nlibrary(emmeans)\n\n\nWelcome to emmeans.\nCaution: You lose important information if you filter this package's results.\nSee '? untidy'\n\n\nCode\npost.hoc.trout <- emmeans (m.trout, pairwise ~ Stream)\n\n\nOm vi inspekterar vår kod emmeans (m.trout, pairwise ~ Stream) så anger vi först namnet på den statistiska modell som vi gjort när vi genomförde vår ANOVA, dvs m.trout. Sedan anger vi att vi vill göra parvisa jämförelser mellan våra bäckar, genom att ange pairwise ~ Stream.\n\n\nStatistiska resultat - post-hoc\nVi skriver in namnet på vår post-hoc analys och kör koden\n\n\nCode\npost.hoc.trout\n\n\n$emmeans\n Stream      emmean   SE df lower.CL upper.CL\n Bjurbacken     223 13.6 15    193.6      251\n Klevabacken    185 13.6 15    155.6      213\n Surdraget      121 13.6 15     91.8      150\n\nConfidence level used: 0.95 \n\n$contrasts\n contrast                 estimate   SE df t.ratio p.value\n Bjurbacken - Klevabacken     38.0 19.2 15   1.977  0.1522\n Bjurbacken - Surdraget      101.8 19.2 15   5.301  0.0002\n Klevabacken - Surdraget      63.8 19.2 15   3.324  0.0121\n\nP value adjustment: tukey method for comparing a family of 3 estimates \n\n\nVi får fram våra resultat av post-hoc analysen. Under rubriken $emmeans ser vi de skattade medelvärderna samt standard error (SE) och konfidensintervall (CL) för öringarnas längd i de olika bäckarna.\nUnder rubriken $contrasts får vi sedan våra parvisa test, det är parvisa t-test med Tukey’s metod för att korrigera p-värden för multipla test. Vi tittar på resultatet rad för rad.\nBjurbacken - Klevabacken har ett p-värde på0.1522. Det betyder att öringarnas längd inte skiljer sig mellan Bjurbäcken och Klevabäcken. Den skillnaden vi ändå kan se i medelvärden under rubriken $emmeans är alltså inte signifikant.\nBjurbacken - Surdraget har ett p-värde på0.0002. Det betyder att öringarnas längd skiljer sig mellan Bjurbäcken och Surdraget. Vi ser under rubriken $emmeans att öringarna är större i Bjurbäcken (223 mm) än i Surdraget (121 mm).\nKlevabacken - Surdraget har ett p-värde på0.0121. Det betyder att öringarnas längd skiljer sig mellan Bjurbäcken och Klevabäcken.Vi ser under rubriken $emmeans att öringarna är större i Klevabäcken (185 mm) än i Surdraget (121 mm)."
  },
  {
    "objectID": "tutorials/anova/index.html#presentera-din-statistiska-analys",
    "href": "tutorials/anova/index.html#presentera-din-statistiska-analys",
    "title": "Envägs ANOVA",
    "section": "Presentera din statistiska analys",
    "text": "Presentera din statistiska analys\nÖringarnas storlek skiljer sig mellan bäckarna (envägs ANOVA, F = 14.353, d.f. = 2 och 15, p < 0.001). Post-hoc test visar att öringarna i Surdraget är minst, och deras storlek skiljer sig signifikant från öringarna i Bjurbäcken (t = 5.301, d.f. = 15, p < 0.001) och Klevabäcken (t = 3.324, d.f. = 15, p = 0.012) medan öringarna i Bjurbäcken och Klevabäcken inte signifikant skiljer sig i storlek (t = 1.977, d.f. = 15, p = 0.152)."
  },
  {
    "objectID": "tutorials/anova/index.html#utvärdera-den-statistiska-modellen",
    "href": "tutorials/anova/index.html#utvärdera-den-statistiska-modellen",
    "title": "Envägs ANOVA",
    "section": "Utvärdera den statistiska modellen",
    "text": "Utvärdera den statistiska modellen\nVar modellen lämplig att använda för ditt dataset?\nVi utvärderar modellen genom diagnostiska grafer genom att använda funktionen plot() på vår statistiska modell.\n\n\nCode\nplot(m.trout)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVi får fyra grafer att utvärdera, de två första är viktigast. Du kan behöva trycka upprepade gånger på ENTER för att se alla graferna (i R kommer de en och en).\nResiduals vs Fitted bör visa en hyfsat rak linje. Den visar hur mycket residualerna (skillnaden mellan dina data och de predikterade värderna) förändras med ökat värde på y-axeln. Residualerna motsvaras av cirklar i grafen. Om du har ett mönster i avvikelserna så betyder det att modellen inta är optimal för dina data.\nNormal Q-Q visar om residualerna är normalfördelade. De bör följa den diagonala streckade linjen. Om de avviker på ett systematiskt sätt är residualerna inte perfekt normalfördelade, och vi kan behöva förändra modellen, exempelvis genom att transformera data.\nScale-Location illustrerar om variationen i datat är lika över alla värden. Om variationen ökar mycket åt höger (ett vanligt fall) så har vi större variation vid högre värden. Kan lösas genom att transformera data.\nResiduals vs Leverage används för att hitta extremvärden som har onormalt stor påverkan på regressionslinjen. Mönstret i grafen är inte intressant, vi letar efter värden som ligger utanför de grå linjerna, speciellt linjerna för 1. Man bör dubbelkolla sådana värden (outliers) och fundera på om de skall vara med i datasetet. Kanske analysera såväl med som utan extremvärderna?"
  },
  {
    "objectID": "tutorials/anova/index.html#publiceringsduglig-figur",
    "href": "tutorials/anova/index.html#publiceringsduglig-figur",
    "title": "Envägs ANOVA",
    "section": "Publiceringsduglig figur",
    "text": "Publiceringsduglig figur\nVi avslutar med att göra en publiceringsduglig figur, och använder oss av paketet ggplot2. Om du inte sedan tidigare har paketet installerat så gör du det med koden install.packages(\"ggplot2\"). Innan du använder paketet behöver du läsa in det i din session i R genom funktionen library()\n\nFörst - en enkel plot med ggplot2\nKoden bygger helt på den vi lärde oss under vår tutorial för t-test, och förklaras inte närmare här.\n\n\nCode\nlibrary(ggplot2)\n\nplot.trout.simple <- ggplot(trout_data, aes(x = Stream, y = Trout.length, fill = Stream)) +\n  stat_summary(geom = \"bar\", fun = mean, width = 0.4) +\n  stat_summary(geom = \"errorbar\", fun.data = mean_se, width = 0.1) +\n  theme_classic()\n\nplot.trout.simple\n\n\n\n\n\n\n\nModifiera din plot så den blir publiceringsduglig\nDet blev en bra start, men vi kan fixa ytterligare med den.\n\nVi vill ha bättre namn på vår y-axel, fixas med ylab()\nVi vill välja andra färger, och dessutom vill vi ha savenska namn med å, ä och ö för våra bäckar. Fixas med scale_fill_manual()\n\n\n\nCode\nlibrary(ggplot2)\n\nplot.trout.final <- ggplot(trout_data, aes(x = Stream, y = Trout.length, fill = Stream)) +\n  stat_summary(geom = \"bar\", fun = mean, width = 0.4) +\n  stat_summary(geom = \"errorbar\", fun.data = mean_se, width = 0.1) +\n  ylab(\"Trout length (mm)\")+\n  scale_fill_manual(values = c(\"Bjurbacken\" = \"darkblue\", \"Klevabacken\" = \"blue\", Surdraget = \"lightblue\"), labels = c(\"Bjurbäcken\", \"Klevabäcken\", \"Surdraget\"))+\nscale_x_discrete(\n  labels = c(\"Bjurbacken\" = \"Bjurbäcken\",\n             \"Klevabacken\" = \"Klevabäcken\",\n             \"Surdraget\" = \"Surdraget\")) +\n  theme_classic()\n\nplot.trout.final\n\n\n\n\n\nFunktionen scale_fill_manual() justerar färger med values och namnen i legenden med labels. Våra förändringar i legenden påverkar dock inte vad som skrivs under våra staplar på x-axeln, då de komemr från vårt dataset. Vi behöver ytterliga en kod, scale_x_discrete(), där vi förklarar hur översättningarna på x-axlen skall se ut. Det är ganska vanligt att man har korta namn på sina olika nivåer av sin faktor (för att få mer lättläst och lättskriven kod, samt undvika specialtecken som kan skapa kompabilitetsproblem) och sedan fyller i det fullständiga namnet eller korrekta stavningen i grafen."
  },
  {
    "objectID": "tutorials/correlation/index.html#publiceringsduglig-figur",
    "href": "tutorials/correlation/index.html#publiceringsduglig-figur",
    "title": "Korrelationer",
    "section": "Publiceringsduglig figur",
    "text": "Publiceringsduglig figur\nVi avslutar med att göra en publiceringsduglig figur, och använder oss av paketet ggplot2. Om du inte sedan tidigare har paketet installerat så gör du det med koden install.packages(\"ggplot2\"). Innan du använder paketet behöver du läsa in det i din session i R genom funktionen library()\n\nFörst - en enkel plot med ggplot2\n\n\nCode\nlibrary(ggplot2)\n\nplot.trees.simple <- ggplot(tree.data, aes(x = diameter, y = height)) +\n  geom_point() +\n  theme_classic()\n\nplot.trees.simple\n\n\n\n\n\nKoden är densamma som för regressioner, förutom att vi tagit bort regressionslinjen eftersom vi gör en korrelation. Se vår tidigare beskrivning för en förklarad kod.\n\n\nPubliceringsbar figur\nDen blev helt ok, men vi kan förbättra den.\n\nVi vill att det skall stå “Tree diameter (m)” på x-axeln, fixas med xlab()\nVi vill att det skall stå “Tree height (m)” på y-axeln, fixas med ylab()\nVi vill välja gröna punkter, och vi vill att de skall vara lite större,fixas med cex och color inom geom_point()\n\n\n\nCode\nlibrary(ggplot2)\n\nplot.trees.final <- ggplot(tree.data, aes(x = diameter, y = height)) +\n  geom_point(cex = 3, colour = \"darkgreen\") +\n  xlab(\"Tree diameter (m)\")+\n  ylab(\"Tree height (m)\")+\n  theme_classic()\n\nplot.trees.final"
  },
  {
    "objectID": "tutorials/factorial-anova/index.html",
    "href": "tutorials/factorial-anova/index.html",
    "title": "Faktoriell ANOVA",
    "section": "",
    "text": "I alla tidigare analyser har vi enbart haft en oberoende variabel (predictor). Ofta har vi dock mer än en oberoende variabel, det kan vara att vi vill undersöka effekten av såväl temperatur (hög, låg) som ursprung (nordlig, sydlig) på grodornas utveckling.\nOm man har två eller fler faktorer har man möjligheten till en interaktion dvs att responsvariabeln beror på hur de oberoende variablarna interagerar. Exempelvis kanske effekten av temperatur på grodornas utveckling beror på vilket ursprung grodorna har. Interaktioner är oftast mycket intressanta rent biologiskt!\nFaktoriella designer är designer med två eller fler faktorer, där alla kombinationer av faktorerna finns. Vi kommer enbart arbeta med exempel där vi bara har två nivåer av varje faktor, eftersom det är enklast att tolka. Metoden klarar dock fler än två nivåer per faktor."
  },
  {
    "objectID": "tutorials/factorial-anova/index.html#läs-in-data",
    "href": "tutorials/factorial-anova/index.html#läs-in-data",
    "title": "Faktoriell ANOVA",
    "section": "Läs in data",
    "text": "Läs in data\nVi har undersökt två arter av växter, och låtit dem växa i låg och hög näringsnivå. Efter fem veckor har vi vägt dem. Påverkar näringsnivån deras storlek?\nLadda ner följande fil size_nutrient.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en mapp med ett lämpligt namn.\nFortsätt med att läsa in datasetet och ge det ett namn, i det här fallet kallar vi det size_nutrient_data En detalerad beskrivning i hur man läser in filer finns i vår tidigare tutorial Läsa in data i R.\nGlöm inte att dokumentera din kod i ett script, med kommentarer som förklarar vad du gör! Se vår tutorial om script om du behöver påminnelse om hur man skapar och använder script.\n\n\nCode\nsize_nutrient_data<-read.table(\"data/size_nutrient.txt\",header=T,sep=\"\\t\",dec=\",\") \n\n\n\nInspektera data\nBörja med att titta på datans struktur med str().\n\n\nCode\nstr(size_nutrient_data)\n\n\n'data.frame':   60 obs. of  3 variables:\n $ Nutrient_level: chr  \"Low\" \"Low\" \"Low\" \"Low\" ...\n $ Species       : chr  \"A\" \"A\" \"A\" \"A\" ...\n $ Weight        : int  10 8 9 5 9 10 8 12 5 5 ...\n\n\n$ Nutrient_level: chr betyder att värderna i kolumnen Nutrient_level är karaktärer dvs text och inte siffror.\n$ Species: chr betyder att värderna i kolumnen Species är karaktärer dvs text och inte siffror.\n$ Weight: int betyder att värderna i kolumnen Weight är heltal\nVisa sedan de fem första raderna av ditt dataset med head() för att se att allt ser korrekt ut\n\n\nCode\nhead(size_nutrient_data)\n\n\n  Nutrient_level Species Weight\n1            Low       A     10\n2            Low       A      8\n3            Low       A      9\n4            Low       A      5\n5            Low       A      9\n6            Low       A     10"
  },
  {
    "objectID": "tutorials/factorial-anova/index.html#visualisera-datat-med-en-enkel-graf",
    "href": "tutorials/factorial-anova/index.html#visualisera-datat-med-en-enkel-graf",
    "title": "Faktoriell ANOVA",
    "section": "Visualisera datat med en enkel graf",
    "text": "Visualisera datat med en enkel graf\nVi gör en enkel graf med boxplot() Eftersom vi har två faktorer behöver vi specificera båda i vår kod, till höger om tilde-tecknet ~.\n\n\nCode\nboxplot(Weight ~ Nutrient_level + Species, data = size_nutrient_data)\n\n\n\n\n\nHur tolkar du datat? Har arterna olika vikt? Blir de tyngre eller lättare vid hög näring? Eller beror effekten av näring på vilken art det är? Det vill säga, verkar det som vi kan ha en interaktion mellan Näring och Art?"
  },
  {
    "objectID": "tutorials/factorial-anova/index.html#statistisk-modellering",
    "href": "tutorials/factorial-anova/index.html#statistisk-modellering",
    "title": "Faktoriell ANOVA",
    "section": "Statistisk modellering",
    "text": "Statistisk modellering\nVi vill nu göra en faktoriell ANOVA för att undersöka om vår responsvariabel (beroende variabel) Weight beror av våra förklarande variabelar (oberoende variabelar) Nutrient_level och Species.\nPå samma sätt som när vi gjorde regression och envägs-ANOVA specificerar en modell med hjälp av funktionen lm() som står för linjär modell. Vi väljer att spara resultatet i ett objekt som vi kallar m.size_nutrient. Jag föredrar att alla mina modeller (resultat av statistka test) har ett namn som börjar med m. för att jag skall veta vad som är dataset och vad som är modeller. Ge alltid dina modeller beskrivande namn.\n\n\nCode\nm.size_nutrient <- lm (Weight ~ Nutrient_level * Species,\n                    data = size_nutrient_data)\n\n\nI vår modell har vi vår responsvariabel (det vi har på y-axeln) till vänster om tilde-tecknet ~ och våra förklarande faktorer till höger. Eftersom vi har två faktorer behöver vi lägga till båda till höger om tilde-tecknet ~.\nNotera att vi har ett multiplikationstecken i vår modell ~ Nutrient_level * Species. Multiplikationstecknet är en genväg som talar om för R att vi vill undersöka effekten av Nutrient_level, effekten av Species, samt interaktionen mellan dem (Nutrient_level: Species). Ett alternativt och mer explicit sätt att skriva modellen är därmed Weight ~ Nutrient_level + Species + Nutrient_level: Species. Det sättet att skriva blir dock väldigt komplicerat om man har fler än två faktorer (dvs det är stor risk för fel i koden).\n\nStatistiska resultat\nVi börjar med en ANOVA-tabell\n\n\nCode\nanova(m.size_nutrient)\n\n\nAnalysis of Variance Table\n\nResponse: Weight\n                       Df Sum Sq Mean Sq F value    Pr(>F)    \nNutrient_level          1 1363.3  1363.3  59.377 2.362e-10 ***\nSpecies                 1 7981.1  7981.1 347.615 < 2.2e-16 ***\nNutrient_level:Species  1 2483.3  2483.3 108.159 1.083e-14 ***\nResiduals              56 1285.7    23.0                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nVi får en ANOVA-tabell och kan inspektera resultatet. Nu kommer en otroligt viktig detalj för att tolka den. Om modellen innehåller interaktioner skall Anova-tabellen läsas nedifrån och uppåt!\nVi börjar nedifrån och ovanför Residualskommer vår interaktion Nutrient_level:Species ... 1.083e-14 ***. Vi ser att p-värdet är mindre än 0.05, dvs interaktionen är signifikant. Det betyder att Effekten av näring på storleken beror på art. Vi kan alltså inte säga huruvida näring påverkar storleken utan att specificera vilken art vi pratar om. Studera figuren ovan så ser du att det stämmer.\nOm interaktionen är signifikant är det inte meningsfullt att tolka varje faktor för sig (oavsett om de är signifikanta eller inte). Man kan ha en situation där det är en signifikant interaktion men ingen av faktorerna har en signifikant effekt i sig själv.\nEnbart om interaktionen inte är signifikant går man uppåt i tabellen och kan tolka de enskilda effekterna av faktorerna på vanligt sätt, är de signifikanta så har de effekt på responsvariabeln.\n\n\nPost-hoc på interaktionen\nVi har nu en signifikant interaktion, som tyder på att de olika arterna svarar olika på ökad näring. I grafen ser det ut som om art B definitivt väger mer om näringen ökar, medan art A kanske minskar i vikt. Eller är den oförändrad? Den spontana tanken vore att göra separata t-test för de båda arterna, men man bör genomföra allt i samma analys. Däremot kan vi gå vidare och göra ett post-hoc-test på vår interaktion i paketet emmeans() som vi tidigare använde i vår envägs-ANOVA.\nOm interaktionen däremot inte är signifikant, skall du inte göra en post-hoc analys av interaktionen.\n\n\nCode\nlibrary(emmeans)\n\n\nWelcome to emmeans.\nCaution: You lose important information if you filter this package's results.\nSee '? untidy'\n\n\nCode\nemmeans(m.size_nutrient, pairwise ~ Nutrient_level | Species)\n\n\n$emmeans\nSpecies = A:\n Nutrient_level emmean   SE df lower.CL upper.CL\n High             5.47 1.24 56     2.99     7.95\n Low              8.80 1.24 56     6.32    11.28\n\nSpecies = B:\n Nutrient_level emmean   SE df lower.CL upper.CL\n High            41.40 1.24 56    38.92    43.88\n Low             19.00 1.24 56    16.52    21.48\n\nConfidence level used: 0.95 \n\n$contrasts\nSpecies = A:\n contrast   estimate   SE df t.ratio p.value\n High - Low    -3.33 1.75 56  -1.905  0.0619\n\nSpecies = B:\n contrast   estimate   SE df t.ratio p.value\n High - Low    22.40 1.75 56  12.803  <.0001\n\n\nSom vi ser har vi modifierat vår formel jämfört med när vi gjorde ett posthoc-test i en envägs-ANOVA, eftersom vi nu har två faktorer. pairwise ~ Nutrient_level | Species betyder att vi gör parvisa jämförelser över nivåerna i faktorn Nutrient_level, och att vi gör det separat för de olika nivåerna i faktorn Species.\nI våra resultat under $emmeans ser vi medelvärden och standard error för de olika nivåerna av våra faktorer, medan resultaten av post-hoc analysen finns under $contrasts. För art A får vi ett p-värde på 0.0619, dvs vikten hos art A påverkas inte signifikant av näringstillgången (men väldigt nära signifikans…). Om vi tittar på art B så ser vi dock ett p-värde på <.0001, det vill säga art B’s vikt påverkas av näringstillgången."
  },
  {
    "objectID": "tutorials/factorial-anova/index.html#presentera-din-statistiska-analys",
    "href": "tutorials/factorial-anova/index.html#presentera-din-statistiska-analys",
    "title": "Faktoriell ANOVA",
    "section": "Presentera din statistiska analys",
    "text": "Presentera din statistiska analys\nVi har en signifikant interaktion mellan näring och art (faktoriell ANOVA, F = 108,2, f.g. = 1 och 56, p < 0.001) vilket betyder att hur vikten påverkas av näring skiljer sig åt för de två arterna. Medan art B väger mer vid hög näring (post-hoc, t = 12.803, df = 56, p < 0.001) har näring ingen effekt på vikten hos art A (post-hoc, t = -1.905, df = 56, p = 0.062). I tillägg till interaktionen är huvudeffekten av såväl näring (F = 59.4, f.g. = 1 och 56, p < 0.001) som art (F = 347,6, f.g. = 1 och 56, p < 0.001) signifikanta."
  },
  {
    "objectID": "tutorials/chi2/index.html#fishers-exakta-test",
    "href": "tutorials/chi2/index.html#fishers-exakta-test",
    "title": "\\(\\chi\\) 2 test (chi-2)",
    "section": "Fisher’s exakta test",
    "text": "Fisher’s exakta test\nOm någon av dina förväntade frekvenser är lägre än fem kan man inte lita på de p-värden som ett \\(\\chi\\) 2 test presenterar. Istället måste vi använda oss av Fisher’s exakta test, genom att använda funktionen fisher.test() istället förchisq.test(). Man har i övrigt samma arbetsgång.\nVi provar Fisher’s exakta test genom att först skapa en korstabell med hanars och honors förekomst på olika djup. Du behöver inte lära dig koden för att skapa en korstabell från grunden i R, du läser oftast in dina data från en fil. Kopiera bara koden och kör den.\n\n\nCode\ndepth.data <- data.frame(\n  \"male\" = c(7, 0),\n  \"female\" = c(2, 5),\n  row.names = c(\"Shallow\", \"Deep\"),\n  stringsAsFactors = FALSE\n)\ncolnames(depth.data) <- c(\"Male\", \"Female\")\n\ndepth.data\n\n\n        Male Female\nShallow    7      2\nDeep       0      5\n\n\nOm vi använder chisq.test() får vi en varning:\n\n\nCode\nm.depth <- chisq.test(depth.data)\n\n\nWarning in chisq.test(depth.data): Chi-squared approximation may be incorrect\n\n\nVi ser på våra förväntade frekvenser att alla är lägre än 5.\n\n\nCode\nm.depth$expected\n\n\n        Male Female\nShallow  4.5    4.5\nDeep     2.5    2.5\n\n\nVi använder oss därför av Fisher´s exakta test.\n\n\nCode\nm.depth.fisher <- fisher.test(depth.data)\nm.depth.fisher\n\n\n\n    Fisher's Exact Test for Count Data\n\ndata:  depth.data\np-value = 0.02098\nalternative hypothesis: true odds ratio is not equal to 1\n95 percent confidence interval:\n 1.449481      Inf\nsample estimates:\nodds ratio \n       Inf \n\n\nVi anger endast ett p-värde om vi använder Fisher´s exakta test."
  },
  {
    "objectID": "tutorials/factorial-anova/index.html#utvärdera-den-statistiska-modellen",
    "href": "tutorials/factorial-anova/index.html#utvärdera-den-statistiska-modellen",
    "title": "Faktoriell ANOVA",
    "section": "Utvärdera den statistiska modellen",
    "text": "Utvärdera den statistiska modellen\nVar modellen lämplig att använda för ditt dataset?\nVi utvärderar modellen genom diagnostiska grafer genom att använda funktionen plot() på vår statistiska modell.\n\n\nCode\nplot(m.size_nutrient)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVi får fyra grafer att utvärdera, de två första är viktigast. Du kan behöva trycka upprepade gånger på ENTER för att se alla graferna (i R kommer de en och en).\nResiduals vs Fitted bör visa en hyfsat rak linje. Den visar hur mycket residualerna (skillnaden mellan dina data och de predikterade värderna) förändras med ökat värde på y-axeln. Residualerna motsvaras av cirklar i grafen. Om du har ett mönster i avvikelserna så betyder det att modellen inta är optimal för dina data.\nNormal Q-Q visar om residualerna är normalfördelade. De bör följa den diagonala streckade linjen. Om de avviker på ett systematiskt sätt är residualerna inte perfekt normalfördelade, och vi kan behöva förändra modellen, exempelvis genom att transformera data.\nScale-Location illustrerar om variationen i datat är lika över alla värden. Om variationen ökar mycket åt höger (ett vanligt fall) så har vi större variation vid högre värden. Kan lösas genom att transformera data.\nResiduals vs Leverage används för att hitta extremvärden som har onormalt stor påverkan på regressionslinjen. Mönstret i grafen är inte intressant, vi letar efter värden som ligger utanför de grå linjerna, speciellt linjerna för 1. Man bör dubbelkolla sådana värden (outliers) och fundera på om de skall vara med i datasetet. Kanske analysera såväl med som utan extremvärderna?"
  },
  {
    "objectID": "tutorials/factorial-anova/index.html#publiceringsduglig-figur",
    "href": "tutorials/factorial-anova/index.html#publiceringsduglig-figur",
    "title": "Faktoriell ANOVA",
    "section": "Publiceringsduglig figur",
    "text": "Publiceringsduglig figur\nVi avslutar med att göra en publiceringsduglig figur, och använder oss av paketet ggplot2. Om du inte sedan tidigare har paketet installerat så gör du det med koden install.packages(\"ggplot2\"). Innan du använder paketet behöver du läsa in det i din session i R genom funktionen library()\n\nFörst - en enkel plot med ggplot2\nKoden bygger på den vi lärde oss under vår tutorial för t-test, och dess huvuddrag förklaras inte närmare här.\nDe få förändringen är att vi under aes() anger olika faktorer underx =och fill =. x= Species betyder att vi har art på x-axeln, medanfill = Nutrient_level betyder att för varje Art skapar vi två staplar, en för varje nivå på Nutrient_level, och dessa får också olika färg.\nUnder stat_summary() lägger vi även till position = \"dodge\", det betyder att de två staplarna (och felstaplarna) skall ligga bredvid varandra och inte ovanpå varandra.\n\n\nCode\nlibrary(ggplot2)\n\nplot.size_nutrient.simple <- ggplot(size_nutrient_data, aes(x = Species, y = Weight, fill = Nutrient_level)) +\n  stat_summary(geom = \"bar\", fun = mean, width = 0.4, position = \"dodge\") +\n  stat_summary(geom = \"errorbar\", fun.data = mean_se, width = 0.1, position = \"dodge\") +\n  theme_classic()\n\nplot.size_nutrient.simple\n\n\n\n\n\n\n\nModifiera din plot så den blir publiceringsduglig\nOk, halvbra start men inte mer. Vi måste jobba vidare med den.\n\nNär vi använde position = “dodge” så hamnar staplar och felstaplar bredvid varandra. Men eftersom felstaplarna är kodade som smalare (width = 0.1) än staplarna (width = 0.4) så är de inte centrerade över staplarna.\nVi vill välja andra färger, och det skall inte stå Nutrient_level på legenden. Fixas med scale_fill_manual()\nVi vill ha med enhet på y-axel, fixas med ylab()\nDet känns mest logiskt att staplarna för Low är till vänster om staplarna för High (man är van att det skall öka när man går åt höger på x-axeln)\n\n\n\nCode\nlibrary(ggplot2)\n\nmanual_dodge <- position_dodge(width = 0.4)\n\nplot.size_nutrient.final <- ggplot(size_nutrient_data, aes(x = Species, y = Weight, fill = factor(Nutrient_level, levels = c(\"Low\", \"High\")))) +\n  stat_summary(geom = \"bar\", fun = mean, width = 0.4, position = manual_dodge) +\n  stat_summary(geom = \"errorbar\", fun.data = mean_se, width = 0.1, position =  manual_dodge) +\n  ylab(\"Weight (g)\")+\n  scale_fill_manual(\n  name = \"Nutrient level\",\n  values = c(\"Low\" = \"lightgreen\", \"High\" = \"darkgreen\"),\n  limits = c(\"Low\", \"High\"))+\n  theme_classic()\n\nplot.size_nutrient.final\n\n\n\n\n\nLösningen på problemet med de icke centrerade felstaplarna är att skapa en manuell dodge som är frikopplad från den faktiska bredden på staplar och felstaplar, det gör vi genom att lägga till en rad innan grafen\nmanual_dodge <- position_dodge(width = 0.4)\nSorteringen av staplarna så att Low är till vänster om High kan antingen göras direkt i datasetet med koden size_nutrient_data$Nutrient_level <- factor(size_nutrient_data$Nutrient_level,levels = c(\"Low\", \"High\")), då kommer de i rätt ordning. För att illustrera ett alternativ så ändrar jag det enbart i grafen istället, sker under aes() med koden fill = factor(Nutrient_level, levels = c(\"Low\", \"High\"))."
  },
  {
    "objectID": "tutorials/ancova/index.html",
    "href": "tutorials/ancova/index.html",
    "title": "ANCOVA",
    "section": "",
    "text": "När vi studerade faktoriella designer hade vi två diskreta faktorer som oberoende variabler. Man skulle dock kunna ha en kontinuerlig variabel och en faktor som oberoende variablar. Det innebär att vi gör en analys med ett antal regressionslinjer, en regressionslinje för varje nivå av vår kontinuerliga faktor. Om vi istället för att göra separata regressioner för varje nivå av vår faktor (exempelvis separata regressioner för varje art) har med art som en faktor i vår analys kan vi testa om det finns en interaktion, dvs om regressionslinjens lutning skiljer sig åt mellan arterna.\nVi kallar en sådan här analys en ANCOVA, vilket står för Analysis of Covariance, där vår kontinuerliga variabel ofta benämns som vår covariat. Specifikationen av modellen är dock identisk som för en faktoriell analys, i båda fallen har vi en responsvariabel och två oberoende variabler."
  },
  {
    "objectID": "tutorials/ancova/index.html#läs-in-data",
    "href": "tutorials/ancova/index.html#läs-in-data",
    "title": "ANCOVA",
    "section": "Läs in data",
    "text": "Läs in data\nVi har undersökt hopplängden hos ett antal grodor av samma art, och även mätt deras storlek. I tillägg vet vi om de är hanar eller honor. Påverkar deras storlek hopplängden, och skiljer det sig åt mellan könen?\nLadda ner följande fil jumping_frogs.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en mapp med ett lämpligt namn.\nFortsätt med att läsa in datasetet och ge det ett namn, i det här fallet kallar vi det size_nutrient_data En detalerad beskrivning i hur man läser in filer finns i vår tidigare tutorial Läsa in data i R.\nGlöm inte att dokumentera din kod i ett script, med kommentarer som förklarar vad du gör! Se vår tutorial om script om du behöver påminnelse om hur man skapar och använder script.\n\n\nCode\njumping_frogs_data<-read.table(\"data/jumping_frogs.txt\",header=T,sep=\"\\t\",dec=\",\") \n\n\n\nInspektera data\nBörja med att titta på datans struktur med str().\n\n\nCode\nstr(jumping_frogs_data)\n\n\n'data.frame':   100 obs. of  3 variables:\n $ Sex        : chr  \"Female\" \"Female\" \"Female\" \"Female\" ...\n $ Size       : num  29.6 14.8 19 21 24.2 ...\n $ Jump_length: num  64.7 54.6 59.2 59.8 62.9 ...\n\n\n$ Sex: chr betyder att värderna i kolumnen Sex är karaktärer dvs text och inte siffror.\n$ Size: num betyder att värderna i kolumnen Size är decimaltal.\n$ Jump_length: num betyder att värderna i kolumnen Jump_length är decimaltal\nVisa sedan de fem första raderna av ditt dataset med head() för att se att allt ser korrekt ut\n\n\nCode\nhead(jumping_frogs_data)\n\n\n     Sex     Size Jump_length\n1 Female 29.56976    64.67883\n2 Female 14.76603    54.62399\n3 Female 19.04707    59.22532\n4 Female 20.99747    59.79079\n5 Female 24.19361    62.86234\n6 Female 21.68416    60.37190"
  },
  {
    "objectID": "tutorials/ancova/index.html#visualisera-datat-med-en-enkel-graf",
    "href": "tutorials/ancova/index.html#visualisera-datat-med-en-enkel-graf",
    "title": "ANCOVA",
    "section": "Visualisera datat med en enkel graf",
    "text": "Visualisera datat med en enkel graf\nVi börjar med att titta på vårt data. De plot-funktioner som är inbyggda i R är dock dåliga på att hantera två regressionslinjer (det går men är omständigt) så vi gör direkt en enkel graf med hjälp av paketet ggplot2. Om du inte sedan tidigare har paketet installerat så gör du det med koden install.packages(\"ggplot2\"). Innan du använder paketet behöver du läsa in det i din session i R genom funktionen library()\n\n\nCode\nlibrary(ggplot2)\n\nplot.jumping_frogs.simple <- ggplot(jumping_frogs_data, aes(x = Size, y = Jump_length, color = Sex)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  theme_classic()\n\nplot.jumping_frogs.simple\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nHur tolkar du datat? Påverkar grodornas vikt deras hopplängd, eller beror det på deras kön? Med andra ord, ser det ut som en interaktion?"
  },
  {
    "objectID": "tutorials/ancova/index.html#statistisk-modellering",
    "href": "tutorials/ancova/index.html#statistisk-modellering",
    "title": "ANCOVA",
    "section": "Statistisk modellering",
    "text": "Statistisk modellering\nVi vill nu göra en ANCOVA för att undersöka om vår responsvariabel (beroende variabel) Jump_length beror av våra förklarande variabelar (oberoende variabelar) Size och Sex.\nPå samma sätt som när vi gjorde regression och envägs-ANOVA specificerar en modell med hjälp av funktionen lm() som står för linjär modell. Vi väljer att spara resultatet i ett objekt som vi kallar m.jumping_frogs. Jag föredrar att alla mina modeller (resultat av statistka test) har ett namn som börjar med m. för att jag skall veta vad som är dataset och vad som är modeller. Ge alltid dina modeller beskrivande namn.\n\n\nCode\nm.jumping_frogs <- lm (Jump_length ~ Size * Sex,\n                    data = jumping_frogs_data)\n\n\nI vår modell har vi vår responsvariabel (det vi har på y-axeln) till vänster om tilde-tecknet ~ och våra förklarande faktorer till höger. Eftersom vi har två faktorer behöver vi lägga till båda till höger om tilde-tecknet ~.\nNotera att vi har ett multiplikationstecken i vår modell ~ Size * Sex. Multiplikationstecknet är en genväg som talar om för R att vi vill undersöka effekten av Size, effekten av Sex, samt interaktionen mellan dem (Size: Sex).\n\nStatistiska resultat\nVi börjar med en ANOVA-tabell\n\n\nCode\nanova(m.jumping_frogs)\n\n\nAnalysis of Variance Table\n\nResponse: Jump_length\n          Df  Sum Sq Mean Sq F value    Pr(>F)    \nSize       1  462.74  462.74  37.858 1.751e-08 ***\nSex        1 2765.62 2765.62 226.266 < 2.2e-16 ***\nSize:Sex   1  643.54  643.54  52.651 1.029e-10 ***\nResiduals 96 1173.39   12.22                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nVi får en ANOVA-tabell och kan inspektera resultatet. Nu kommer en otroligt viktig detalj för att tolka den. Om modellen innehåller interaktioner skall Anova-tabellen läsas nedifrån och uppåt!\nVi börjar nedifrån och ovanför Residualskommer vår interaktion Size:Sex ... 1.029e-10. Vi ser att p-värdet är mindre än 0.05, dvs interaktionen är signifikant. Det betyder att Effekten av storleken på hopplängden beror på kön. Studera figuren ovan så ser du att det stämmer.\nOm interaktionen är signifikant är det inte meningsfullt att tolka varje faktor för sig (oavsett om de är signifikanta eller inte). Man kan ha en situation där det är en signifikant interaktion men ingen av faktorerna har en signifikant effekt i sig själv.\nEnbart om interaktionen inte är signifikant går man uppåt i tabellen och kan tolka de enskilda effekterna av faktorerna på vanligt sätt, är de signifikanta så har de effekt på responsvariabeln.\n\n\nPost-hoc på interaktionen\nVi har nu en signifikant interaktion, visar att effekten av storlek på hopplängd skiljer sig åt hos de två könen. Det kan även vara intressant att veta om storlek över huvud taget har någon effekt på hopplängden för båda könen, om man studerar grafen kan man tänka sig att hanarnas storlek inte påverkar deras hopplängd. Vi kan testa det genom ett post-hoc test i paketet emmeans() som vi tidigare använde i vår envägs-ANOVA.\nOm interaktionen däremot inte är signifikant, skall du inte göra en post-hoc analys av interaktionen.\n\n\nCode\nlibrary(emmeans)\n\n\nWelcome to emmeans.\nCaution: You lose important information if you filter this package's results.\nSee '? untidy'\n\n\nCode\nemtrends(m.jumping_frogs, ~ Sex, var = \"Size\", infer = TRUE)\n\n\n Sex    Size.trend     SE df lower.CL upper.CL t.ratio p.value\n Female     0.7870 0.0816 96    0.625   0.9489   9.648  <.0001\n Male      -0.0699 0.0854 96   -0.239   0.0996  -0.818  0.4152\n\nConfidence level used: 0.95 \n\n\nSom vi ser har vi modifierat vår formel jämfört med när vi gjorde ett posthoc-test i en envägs-ANOVA, eftersom vi nu har två faktorer. Den är dessutom annorlunda från tvåvägs-anova, eftersom vi inte har två nivåer av båda faktorerna. ~ Sex, var = \"Size\", infer = TRUE betyder att vi undersöker hur Size påverkar Size, och vi kör det separat för de två könen. infer = TRUE betyder att vi vill ha p-värden.\nVi ser att för honor har vi en signifikant effekt av storlek på hopplängd (p < 0.001) mewn ingen effekt för hanar (p = 0.415) ## Presentera din statistiska analys\nVi har en signifikant interaktion mellan storlek och kön (ANCOVA, F = 52.651, df = 1 och 96, p < 0.001) vilket betyder att hur hopplängden påverkas av storlek skiljer sig åt för de två könen. Medan hopplängden ökar med storlek för honorna (post-hoc, t = 9.648, df = 96, p < 0.001) så påverkas inte hopplängden hos hanarna av deras storlek (post-hoc, t = -0.818, df = 96, p = 0.415). I tillägg till interaktionen är huvud effekten av såväl storlek (ANCOVA, F = 37.858, df = 1 och 96, p < 0.001) som kön (ANCOVA, F = 226.266, df = 1 och 96, p < 0.001) signifikanta."
  },
  {
    "objectID": "tutorials/ancova/index.html#utvärdera-den-statistiska-modellen",
    "href": "tutorials/ancova/index.html#utvärdera-den-statistiska-modellen",
    "title": "ANCOVA",
    "section": "Utvärdera den statistiska modellen",
    "text": "Utvärdera den statistiska modellen\nVar modellen lämplig att använda för ditt dataset?\nVi utvärderar modellen genom diagnostiska grafer genom att använda funktionen plot() på vår statistiska modell.\n\n\nCode\nplot(m.jumping_frogs)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVi får fyra grafer att utvärdera, de två första är viktigast. Du kan behöva trycka upprepade gånger på ENTER för att se alla graferna (i R kommer de en och en).\nResiduals vs Fitted bör visa en hyfsat rak linje. Den visar hur mycket residualerna (skillnaden mellan dina data och de predikterade värderna) förändras med ökat värde på y-axeln. Residualerna motsvaras av cirklar i grafen. Om du har ett mönster i avvikelserna så betyder det att modellen inta är optimal för dina data.\nNormal Q-Q visar om residualerna är normalfördelade. De bör följa den diagonala streckade linjen. Om de avviker på ett systematiskt sätt är residualerna inte perfekt normalfördelade, och vi kan behöva förändra modellen, exempelvis genom att transformera data.\nScale-Location illustrerar om variationen i datat är lika över alla värden. Om variationen ökar mycket åt höger (ett vanligt fall) så har vi större variation vid högre värden. Kan lösas genom att transformera data.\nResiduals vs Leverage används för att hitta extremvärden som har onormalt stor påverkan på regressionslinjen. Mönstret i grafen är inte intressant, vi letar efter värden som ligger utanför de grå linjerna, speciellt linjerna för 1. Man bör dubbelkolla sådana värden (outliers) och fundera på om de skall vara med i datasetet. Kanske analysera såväl med som utan extremvärderna?"
  },
  {
    "objectID": "tutorials/ancova/index.html#publiceringsduglig-figur",
    "href": "tutorials/ancova/index.html#publiceringsduglig-figur",
    "title": "ANCOVA",
    "section": "Publiceringsduglig figur",
    "text": "Publiceringsduglig figur\nVi avslutar med att göra en publiceringsduglig figur, och använder oss av paketet ggplot2. Om du inte sedan tidigare har paketet installerat så gör du det med koden install.packages(\"ggplot2\"). Innan du använder paketet behöver du läsa in det i din session i R genom funktionen library()\n\nFörst - en enkel plot med ggplot2\n\n\nModifiera din plot så den blir publiceringsduglig"
  },
  {
    "objectID": "tutorials/non-parametric/index.html",
    "href": "tutorials/non-parametric/index.html",
    "title": "Icke-parametriska tester",
    "section": "",
    "text": "De statistiska test vi behandlat nu är parametriska test, dvs de förutsätter att datan eller residualerna följer vissa fördelningar (exempelvis normalfördelning). Simuleringar visar också att parametriska modeller är väldigt robusta även mot avvikelser i normalförderade residualer (se exempelvis Knief & Forstmeier 2021). Om residualerna dessutom avviker från normalfördelning kan det i många fall lösas genom transformeringar (se tidigare tutorial) eller genom att använda generaliserade linjära modeller som kan specificera en annan errorstruktur (kommer presenteras i en framtida tutorial).\nIbland har man dock väldigt “konstiga” data, och speciellt om de samtidigt kommer från små dataset så kan man ibland behöva överväga icke-parametriska metoder.\nIcke-parametriska metoder bygger på att värderna rankas, dvs är ett visst värde generellt högre eller lägre än de andra värderna. Testen använder sig inte av de exakta mätvärderna och tappar därmed mycket information (de är svaga test). Testen har svårare att upptäcka mönster som faktiskt finns och skall därmed bara användas i nödfall.\nMan kan överväga ickeparametriska metoder om:\nIcke-parametriska test skall ses som ett svagt test som används som en nödlösning i små och avvikande dataset. Data som uppfyller många av punkterna ovan kan analyseras med parametriska test om datasetet är stort nog."
  },
  {
    "objectID": "tutorials/non-parametric/index.html#icke-paramatriska-test",
    "href": "tutorials/non-parametric/index.html#icke-paramatriska-test",
    "title": "Icke-parametriska tester",
    "section": "Icke-paramatriska test",
    "text": "Icke-paramatriska test\nDe icke-parametriska testen som oftast används är:\n\nWilcoxons test - alternativ till t-test\nKruskal Wallis test - alternativ till envägs-ANOVA\nSpearman-korrelation - alternativ till parametrisk korrelation"
  },
  {
    "objectID": "tutorials/non-parametric/index.html#mann-whitney-u-test",
    "href": "tutorials/non-parametric/index.html#mann-whitney-u-test",
    "title": "Icke-parametriska tester",
    "section": "Mann-Whitney-U test",
    "text": "Mann-Whitney-U test\nWilcoxons test (kallas ibland Mann-Whitney U-test) används som ett icke-parametriskt alternativ till t-test\nVi vill undersöka om den sydliga kärrsnäppans häckningsframgång kan förbättras om man har predatorkontroll. VI har därför inventerat antalet ungar hos honor i slumpvis utvalda bon i områden där man haft predatorkontroll, och områden där inga åtgärder gjorts.\n\nLäs in data\nLadda ner följande fil dunlin.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en mapp med ett lämpligt namn.\nFortsätt med att läsa in datasetet och ge det ett namn, i det här fallet kallar vi det dunlin_data. En detalerad beskrivning i hur man läser in filer finns i vår tidigare tutorial Läsa in data i R.\nGlöm inte att dokumentera din kod i ett script, med kommentarer som förklarar vad du gör! Se vår tutorial om script om du behöver påminnelse om hur man skapar och använder script.\n\n\nCode\ndunlin_data <- read.table(\"data/dunlin.txt\",\n                           header=T,\n                           sep=\"\\t\",\n                           dec=\",\") \n\n\n\n\nInspektera data\nBörja med att titta på datans struktur med str().\n\n\nCode\nstr(dunlin_data)\n\n\n'data.frame':   14 obs. of  2 variables:\n $ offspring: int  0 0 1 0 2 0 0 3 4 3 ...\n $ treatment: chr  \"control\" \"control\" \"control\" \"control\" ...\n\n\n\n\nCode\nhead(dunlin_data)\n\n\n  offspring treatment\n1         0   control\n2         0   control\n3         1   control\n4         0   control\n5         2   control\n6         0   control\n\n\nDet ser ut som om vi har många nollor i datasetet. Låt oss se på ett histogram:\n\n\nCode\nhist(dunlin_data$offspring)\n\n\n\n\n\nDe flesta honor verkar inte ha fått några ungar. Låt oss se på en QQ-plot som vi även använde i vår tutorial om t-test\n\n\nCode\nqqnorm(dunlin_data$offspring)\n\n\n\n\n\nVi vill att våra värden skall följa en diagonal, men det gör de inte. Vi har ett dataset som inte uppfyller t-testets krav på normalfördelade data, och vi kan inte transformera pg.a. att datasetet mest består av nollvärden som kommer fortsätta att vara nollvärden.\n\n\nVisualisera datat med en enkel graf\nVi gör en enkel graf med boxplot()\n\n\nCode\nboxplot(offspring~treatment, \n        data = dunlin_data)\n\n\n\n\n\nHur tolkar du grafen? Ser det ut som att antalet avkomma skiljer sig åt beroende på om det är predatorkontroll eller ej?"
  },
  {
    "objectID": "tutorials/non-parametric/index.html#statistisk-modellering",
    "href": "tutorials/non-parametric/index.html#statistisk-modellering",
    "title": "Icke-parametriska tester",
    "section": "Statistisk modellering",
    "text": "Statistisk modellering\nVi vill nu göra ett Wilcoxons test för att undersöka om vår responsvariabel (beroende variabel) offspring beror av vår förklarande variabel (oberoende variabel) treatment, med andra ord om antalet avkomma beror av huruvida området haft predatorkontroll eller ej\nVi specificerar en modell med hjälp av funktionen wilcox.test() och väljer att spara resultatet i ett objekt som vi kallar m.dunlin.\n\n\nCode\nm.dunlin<-wilcox.test(offspring~treatment,\n                    data=dunlin_data)\n\n\nWarning in wilcox.test.default(x = DATA[[1L]], y = DATA[[2L]], ...): cannot\ncompute exact p-value with ties\n\n\nVi får en varning Warning: cannot compute exact p-value with ties. Det betyder att testet upptäcker att vissa värden är samma (vi har många nollor) och att p-värderna därmed inte går att lita på fullt ut. Det är dock oftast inga proble.\n\nStatistiska resultat\nVi tittar på resultatet genom att skriva in modellens namn och köra den\n\n\nCode\nm.dunlin\n\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  offspring by treatment\nW = 9.5, p-value = 0.04704\nalternative hypothesis: true location shift is not equal to 0\n\n\nVi kan nu inspektera resultatet. Vi får teststatistika (W-värde) samt ett p-värde. Vi får inga frigetsgrader i icke-parametriska test\nEftersom vårt p-värde är mindre än 0.05 säger vi att antalet avkommor skiljer sig åt beroende på behandling. Stämmer det om du tittar på din boxplot?"
  },
  {
    "objectID": "tutorials/non-parametric/index.html#presentera-din-statistiska-analys",
    "href": "tutorials/non-parametric/index.html#presentera-din-statistiska-analys",
    "title": "Icke-parametriska tester",
    "section": "Presentera din statistiska analys",
    "text": "Presentera din statistiska analys\nDen sydliga kärrsnäppan fårt fler avkommor om man tillämpar predatorkontroll än i områden utan predatorkontroll (Wilcoxons test, W = 9.5, p = 0.047)."
  },
  {
    "objectID": "tutorials/non-parametric/index.html#wilcoxons-test",
    "href": "tutorials/non-parametric/index.html#wilcoxons-test",
    "title": "Icke-parametriska tester",
    "section": "Wilcoxons test",
    "text": "Wilcoxons test\nWilcoxons test (kallas ibland Mann-Whitney U-test) används som ett icke-parametriskt alternativ till t-test\nVi vill undersöka om den sydliga kärrsnäppans häckningsframgång kan förbättras om man har predatorkontroll. Vi har därför inventerat antalet ungar hos honor i slumpvis utvalda bon i områden där man haft predatorkontroll, och områden där inga åtgärder gjorts.\n\nLäs in data\nLadda ner följande fil dunlin.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en mapp med ett lämpligt namn.\nFortsätt med att läsa in datasetet och ge det ett namn, i det här fallet kallar vi det dunlin_data. En detalerad beskrivning i hur man läser in filer finns i vår tidigare tutorial Läsa in data i R.\nGlöm inte att dokumentera din kod i ett script, med kommentarer som förklarar vad du gör! Se vår tutorial om script om du behöver påminnelse om hur man skapar och använder script.\n\n\nCode\ndunlin_data <- read.table(\"data/dunlin.txt\",\n                           header=T,\n                           sep=\"\\t\",\n                           dec=\",\") \n\n\n\n\nInspektera data\nBörja med att titta på datans struktur med str().\n\n\nCode\nstr(dunlin_data)\n\n\n'data.frame':   14 obs. of  2 variables:\n $ offspring: int  0 0 1 0 2 0 0 3 4 3 ...\n $ treatment: chr  \"control\" \"control\" \"control\" \"control\" ...\n\n\n\n\nCode\nhead(dunlin_data)\n\n\n  offspring treatment\n1         0   control\n2         0   control\n3         1   control\n4         0   control\n5         2   control\n6         0   control\n\n\nDet ser ut som om vi har många nollor i datasetet. Låt oss se på ett histogram:\n\n\nCode\nhist(dunlin_data$offspring)\n\n\n\n\n\nDe flesta honor verkar inte ha fått några ungar. Låt oss se på en QQ-plot som vi även använde i vår tutorial om t-test\n\n\nCode\nqqnorm(dunlin_data$offspring)\nqqline(dunlin_data$offspring)\n\n\n\n\n\nVi vill att våra värden skall följa en diagonal, men det gör de inte. Vi har ett dataset som inte uppfyller t-testets krav på normalfördelade data, och vi kan inte transformera pg.a. att datasetet mest består av nollvärden som kommer fortsätta att vara nollvärden.\n\n\nVisualisera datat med en enkel graf\nVi gör en enkel graf med boxplot()\n\n\nCode\nboxplot(offspring~treatment, \n        data = dunlin_data)\n\n\n\n\n\nHur tolkar du grafen? Ser det ut som att antalet avkomma skiljer sig åt beroende på om det är predatorkontroll eller ej?\n\n\nStatistisk modellering\nVi vill nu göra ett Wilcoxons test för att undersöka om vår responsvariabel (beroende variabel) offspring beror av vår förklarande variabel (oberoende variabel) treatment, med andra ord om antalet avkomma beror av huruvida området haft predatorkontroll eller ej\nVi specificerar en modell med hjälp av funktionen wilcox.test() och väljer att spara resultatet i ett objekt som vi kallar m.dunlin.\n\nm.dunlin<-wilcox.test(offspring~treatment,\n                    data=dunlin_data)\n\nWarning in wilcox.test.default(x = DATA[[1L]], y = DATA[[2L]], ...): cannot\ncompute exact p-value with ties\n\n\nVi får en varning Warning: cannot compute exact p-value with ties. Det betyder att testet upptäcker att vissa värden är identiska (vi har många nollor) och att p-värderna därmed inte går att lita på fullt ut. Det är dock oftast inga problem.\n\n\nStatistiska resultat\nVi tittar på resultatet genom att skriva in modellens namn och köra den\n\n\nCode\nm.dunlin\n\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  offspring by treatment\nW = 9.5, p-value = 0.04704\nalternative hypothesis: true location shift is not equal to 0\n\n\nVi kan nu inspektera resultatet. Vi får teststatistika (W-värde) samt ett p-värde. Vi får inga frigetsgrader i det här testet.\nEftersom vårt p-värde är mindre än 0.05 säger vi att antalet avkommor skiljer sig åt beroende på behandling. Stämmer det om du tittar på din boxplot?\n\n\nPresentera din statistiska analys\nDen sydliga kärrsnäppan fårt fler avkommor om man tillämpar predatorkontroll än i områden utan predatorkontroll (Wilcoxons test, W = 9.5, p = 0.047)."
  },
  {
    "objectID": "tutorials/non-parametric/index.html#kruskal-wallis-test",
    "href": "tutorials/non-parametric/index.html#kruskal-wallis-test",
    "title": "Icke-parametriska tester",
    "section": "Kruskal Wallis test",
    "text": "Kruskal Wallis test\nKruskal Wallis test är en ickeparametrisk ersättning till envägs ANOVA. Det är ett svagare och mindre flexibelt test än en vanlig envägs ANOVA och skall bara användas i nödfall.\nVi vill undersöka om täckningsgraden av blåbär skiljer sig åt i tre skogar. Täckningsgraden har skattats enligt Braun-Blanquet-skalan med fem nivåer (1-5) där täckningsgraden ökar från 1 -> 5. Data är därmed ordnade (1 är lägre än 5) men på ordinalskala (kategorierna är inga mätvärden).\n\nLäs in data\nLadda ner följande fil cover.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en mapp med ett lämpligt namn.\n\n\nCode\ncover_data <- read.table(\"data/cover.txt\",\n                           header=T,\n                           sep=\"\\t\",\n                           dec=\",\") \n\n\n\n\nInspektera data\nBörja med att titta på datans struktur med str().\n\n\nCode\nstr(cover_data)\n\n\n'data.frame':   30 obs. of  2 variables:\n $ Cover.cathegory: int  1 2 1 4 3 2 3 1 1 2 ...\n $ Forest         : chr  \"A\" \"A\" \"A\" \"A\" ...\n\n\n\n\nCode\nhead(cover_data)\n\n\n  Cover.cathegory Forest\n1               1      A\n2               2      A\n3               1      A\n4               4      A\n5               3      A\n6               2      A\n\n\nLåt oss se på ett histogram\n\n\nCode\nhist(cover_data$Cover.cathegory)\n\n\n\n\n\nVi ser att våra data ser väldigt jämna ut, och kanske inte är normalfördelade. Dessutom vet vi att det är ordinaldata, dvs vår responsvariabel är inte mätvärden utan i ordnade kategorier. Bara det senare faktumet gör att vi inte skall använda oss av en vanlig envägs-ANOVA.\n\n\nVisualisera datat med en enkel graf\nVi gör en enkel graf med boxplot()\n\n\nCode\nboxplot(Cover.cathegory~Forest, \n        data = cover_data)\n\n\n\n\n\nHur tolkar du grafen? Ser det ut som att blåbärens täckningsgrad skiljer sig åt mellan skogarna?\n\n\nStatistisk modellering\nVi vill nu göra ett Kruskal Wallis test för att undersöka om vår responsvariabel (beroende variabel) Cover.cathegory beror av vår förklarande variabel (oberoende variabel) Forest\nVi specificerar en modell med hjälp av funktionen kruskal.test() och väljer att spara resultatet i ett objekt som vi kallar m.cover.\n\nm.cover<-kruskal.test(Cover.cathegory~Forest,\n                    data=cover_data)\n\n\n\nCode\nm.cover\n\n\n\n    Kruskal-Wallis rank sum test\n\ndata:  Cover.cathegory by Forest\nKruskal-Wallis chi-squared = 11.883, df = 2, p-value = 0.002629\n\n\n\n\nPost-hoc test\nVi har en signifikant efekt av Forest, d.v.s. täckningsgraden för blåbär skiljer sig åt mellan de olika skogarna. Men vilka skogar skiljer sig åt? Vi behöver göra ett post-hoc test! Om vi inte hade haft en signifikant effekt skall vi däremot inte göra ett post-hoc test.\nNär man gör ett posthoc-test på en icke-parametrisk envägs-ANOVA använder man sig av Dunnets Test, vilket finns tillgängligt i paketet dunn.test. Om du inte sedan tidigare har paketet installerat så gör du det med koden install.packages(\"dunn.test\"). Innan du använder paketet behöver du läsa in det i din session i R genom funktionen library()\nNär vi läst in paketet använder vi oss av funktionen dunn.test(). Först anger vi vår responsvariabel, och det gör vi enligt formeln Datatset$Variabel, vilket i vårat fall blir cover_data$Cover.cathegory. Efter det anger vi vår förklarande faktor på samma sätt, vilket blir cover_data$Forest, och slutligen anger vi metoden för att korrigera p-värden för multipla test. Vanligt är att använda sig av Holm’s metod, anges med method=\"holm\".\n\nlibrary(dunn.test)\n\ndunn.test(cover_data$Cover.cathegory,cover_data$Forest,method=\"holm\")\n\n  Kruskal-Wallis rank sum test\n\ndata: x and group\nKruskal-Wallis chi-squared = 11.8825, df = 2, p-value = 0\n\n                           Comparison of x by group                            \n                                    (Holm)                                     \nCol Mean-|\nRow Mean |          A          B\n---------+----------------------\n       B |  -3.414601\n         |    0.0010*\n         |\n       C |  -1.298327   2.116273\n         |     0.0971     0.0343\n\nalpha = 0.05\nReject Ho if p <= alpha/2\n\n\nVi får en tabell med jämförelser. Om vi börjar med Kolumn A och Rad B får vi p-värdet 0.0010. Det betyder att täckningsgraden för blåbär skiljer sig åt mellan skogarna A och B.\nKolumn A och rad C ger ett p-värde på 0.0971. Täckningsgraden skiljer sig alltså inte åt mellan skogarna A och C.\nKolumn B och rad C ger ett p-värde på 0.0343. Täckningsgraden av blåbär skiljer sig åt mellan skogarna B och C.\n\n\nPresentera din statistiska analys\nTäckningsgraden av blåbär skiljer sig åt mellan de olika skogarna (Kruskal Wallis test, \\(\\chi\\) 2 = 11.883,d.f. = 2, p = 0.003). Post-hoc analys visar att täckningsgraden är högre i skog B än i skog A (Dunnet’s test, p = 0.001) och C (Dunnet’s test, p = 0.034). Täckningsgraden skiljer sig inte åt mellan skog A och C (Dunnet’s test, p = 0.097)."
  },
  {
    "objectID": "tutorials/non-parametric/index.html#test-för-normalfördelning",
    "href": "tutorials/non-parametric/index.html#test-för-normalfördelning",
    "title": "Icke-parametriska tester",
    "section": "Test för normalfördelning",
    "text": "Test för normalfördelning\nJag rekommenderar inte att du testar för normalfördelning om du har stora dataset. Testen undersöker avvikelse från normalfördelning, och ju mer data du har, desto kraftfullare blir testen och kan upptäcka minimala avvikelser som inte spelar någon praktisk roll för de statistiska testen. Men om du ändå vill ha ett test så använd Shapiro Wilk’s test, i funktionen shapiro.test():\n\n\nCode\nshapiro.test(dunlin_data$offspring)\n\n\n\n    Shapiro-Wilk normality test\n\ndata:  dunlin_data$offspring\nW = 0.79047, p-value = 0.003814\n\n\nOm testet är icke-signifikant betyder det att data inte avviker från normalfördelning (dvs data är normalfördelat). Om histogramen ser bra ut, men du ändå får en signifikant avvikelse från normalfördelning (speciellt vid större dataset) skulle jag gå på histogramen.\nSom ett exempel på problemen med test för normalfördelning så simulerar jag 2000 värden från en normalfördelning:\n\n\nCode\nset.seed(62874)\n\nsimdata <- rnorm(mean = 100, sd = 50, n = 2000)\n\n\nVi gör sedan ett histogram - det ser extremt normalfördelat ut!\n\n\nCode\nhist(simdata)\n\n\n\n\n\nMen tack vare att vi har så många värden så tycker Shapiro Wilk’s test att våra data (som kommer från en normalfördelning) signifikant avviker från normalfördelningen.\n\n\nCode\nshapiro.test(simdata)\n\n\n\n    Shapiro-Wilk normality test\n\ndata:  simdata\nW = 0.99833, p-value = 0.04167"
  },
  {
    "objectID": "tutorials/non-parametric/index.html#spearman-korrelation",
    "href": "tutorials/non-parametric/index.html#spearman-korrelation",
    "title": "Icke-parametriska tester",
    "section": "Spearman-korrelation",
    "text": "Spearman-korrelation\nEn vanlig korrelationsanalys som vi tidigare gjort kräver att datat är normalfördelat, och även om det kan hantera mindre avvikelser från det så har man ibland data som inte alls är normalfördelat. Då använder man sig av Spearman-korrelation, som är en icke-parametrisk korrelationsanalys som baserar sig på datats rank och inte på de faktiska värderna. Därmed är det mindre kraftfullt än en parametrisk korrelation, men kan hantera avvikande data.\n\nLäs in data\nLadda ner följande fil spearman.txt (högerklicka, välj “spara länk som”) och spara filen på din hårddisk i en mapp med ett lämpligt namn.\n\n\nCode\nspearman_data <- read.table(\"data/spearman.txt\",\n                           header=T,\n                           sep=\"\\t\",\n                           dec=\",\") \n\n\n\n\nInspektera data\nBörja med att titta på datans struktur med str().\n\n\nCode\nstr(spearman_data)\n\n\n'data.frame':   20 obs. of  2 variables:\n $ A: num  0.664 0.941 0.768 0.912 0.925 ...\n $ B: num  0.778 0.61 0.578 0.974 0.656 ...\n\n\n\n\nCode\nhead(spearman_data)\n\n\n          A         B\n1 0.6640666 0.7782157\n2 0.9413902 0.6104316\n3 0.7678628 0.5783860\n4 0.9118415 0.9743616\n5 0.9249759 0.6561892\n6 0.7146678 0.9645745\n\n\nLåt oss se på ett histogram över variabel A\n\n\nCode\nhist(spearman_data$A)\n\n\n\n\n\nDet ser verkligen inte ut som en normalfördelning. Hur ser variabel B ut?\n\n\nCode\nhist(spearman_data$B)\n\n\n\n\n\nVariabel B ser lite bättre ut, men det är som helhet ett dataset som avviker kraftigt från normalfördelningen. Att analysera det med en parametrisk korrelation bryter mot dess antagande om normalfördelning, och då kan vi inte lite på en sådan korrelations resultat.\n\n\nVisualisera datat\nSom vanligt gör vi en graf innan vi börjar med vår statistiska modellering\n\n\nCode\nplot(B ~ A, data = spearman_data)\n\n\n\n\n\nVi ser i grafen att det eventuellt är en positiv korrelation mellan A och B, men också att speciellt variabel A har en underlig fördelning med mest låga eller höga värden, vilket vi också såg i vårt histogram.\n\n\nStatistisk modellering\nVi gör nu en icke-parametrisk korrelation, och den har stora likheter med korrelationen vi tidigare gjort. Vi använder oss fortfarande av funktionen cor.test(), den enda skillnaden är att vi anger method = \"s\" (står för Spearman) där vi tidigare angett \"p\"\n\nm.spearman <-cor.test(spearman_data$A, spearman_data$B, method = \"s\")\n\n\n\nResultat\nVi skriver in modellens namn och tittar på resultatet\n\n\nCode\nm.spearman\n\n\n\n    Spearman's rank correlation rho\n\ndata:  spearman_data$A and spearman_data$B\nS = 782, p-value = 0.07226\nalternative hypothesis: true rho is not equal to 0\nsample estimates:\n      rho \n0.4120301 \n\n\nVi ser att A och B inte är signifikant korrelerade eftersom p-värdet är 0.07226. Vi får också en korrelationskoefficient (kallas rho) på 0.412.\n\n\nSkillnad i resultat mot parametrisk korrelation\nVad hade hänt om vi analyserat datat med en parametrisk korrelation? Vi testar, genom att använda method = \"p\"\n\nm.pearson <-cor.test(spearman_data$A, spearman_data$B, method = \"p\")\nm.pearson\n\n\n    Pearson's product-moment correlation\n\ndata:  spearman_data$A and spearman_data$B\nt = 2.6376, df = 18, p-value = 0.01672\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.1115075 0.7866933\nsample estimates:\n      cor \n0.5279756 \n\n\nVi får nu ett signifikant p-värde, och om vi inte hade vetat att våra data inte var normalfördelade hade vi dragit den felaktiga slutsatsen att A och B var positivt korrelerade. Men eftersom datat inte uppfyller kraven för att få göra en parametrisk korrelation så kan vi inte lite på p-värderna från en sådan korrelation."
  },
  {
    "objectID": "tutorials/transformations/index.html",
    "href": "tutorials/transformations/index.html",
    "title": "Transformeringar",
    "section": "",
    "text": "De dataset vi jobbat med hittils har haft responsvariablar som varit normalfördelade, och om vi gjort ett histogram över dem har de sett ut mer eller mindre på följande sätt:"
  },
  {
    "objectID": "tutorials/transformations/index.html#kvadratrots-transformering",
    "href": "tutorials/transformations/index.html#kvadratrots-transformering",
    "title": "Transformeringar",
    "section": "Kvadratrots-transformering",
    "text": "Kvadratrots-transformering\nEn vanlig typ av transformering är kvadratrots-transformering, vilket man kan överväga i följande fall\n\nData är höger-skevt (se beskrivning nedan). Vid extremt höger-skevt data kan man överväga log-transformering\nMan har räknedata med ett medelvärde mindre än ca 20\nVariansen ökar med medelvärdet (vanligt om man har räknedata)\n\nEn vanlig typ av data är räknedata (count data), vi kan ha räknat antalet individer, antalet frön eller avkommor. Det är en datatyp som enbart innehåller heltal, och som inte kan vara negativ (man säger att den följer en poisson-fördelning och inte en normalfördelning). Om man har ett lågt medelvärde (lägre än 20) så kommer man få en skev fördelning (se exemplet nedan). Vi simulerar räknedata från en poisson-fördelning och gör ett histogram nedan. Vi ser att variationen är störe för höga än för låga värden (vi säger att förelningen är höger-skev, eller right-skewed).\n\n\nCode\nset.seed (12768)\npoisson.data<-rpois(n = 2000, lambda = 4)\nhist(poisson.data, col = \"red\",main = \"Histogram of Poisson data with mean of 4\")\n\n\n\n\n\nEftersom våra statistiska test förutsätter att antingen data eller residualerna är normalfördelade kommer testen att få problem med den här typen av data. Vi kommer att få p-värden, men vi kan inte lita på dem eftersom förutsättningarna för modellen inte uppfylls. Som tur är kan vi uppfylla kraven på normalfördelat data/residualer genom att transformera vår responsvariabel!\nDen transformationen man använder sig av om man har räknadata med låga medelvärden och ett histogram som är höger-skevt är kvadratrots-transformering.\nTransformeringen är enkel, vi drar kvadratroten ur alla tal i vår responsvariabel. Det gör att alla tal blir mindre, men ju större talet är desto större förminskning får det, och vi blir av med höger-skevheten. Vi kan illustrera det genom att se hur mycket ett visst tal minskar om vi drar roten ur det.\n\n\n\nTal\nRoten ur talet\nHur mycket minskar talet\n\n\n2\n1.41\n0.59\n\n\n10\n3.16\n6.84\n\n\n\nSom vi ser minskar stora tal mer än små tal, vilket gör att höger-skevheten minskar. Vi använder oss av funktionen sqrt() för att kvadratrots-transformera responsvariabeln. Låt oss se på ett histogram när vi transformerat vår data!\n\n\nCode\nhist(sqrt(poisson.data),col = \"red\", main = \"Histogram of poisson data after square root transformation\")\n\n\n\n\n\nNu blev histogrammet mycket mer lik en normalfördelning. Det innebär att om vi kvadratrot-transformerar vår responsvariabel så kan vi använda våra vanliga statistiska tester (t-test, regression, anova etc) trots att vår data inte var normalfördelad innan transformeringen.\nObservera att om vårt data redan är normalfördelat så förstör en kvadratrots-transformering den fördelningen. Vi skall alltså bara använda den om vi behöver det.\nProblemet med höger-skevhet är vanligast om man har låga medelvärden. Är medelvärdet av räknetal högre än ca 20 antar fördelningen något som kan approximeras till en normalfördeln. Då behövs ingen transformering. Vi kan illustrera det nedan, nu har vi räknedata med ett medelvärde på 35.\n\n\nCode\nset.seed (12768)\npoisson.data.larger.mean<-rpois(n = 2000, lambda = 35)\nhist(poisson.data.larger.mean, col = \"red\", main = \"Histogram of Poisson data with mean of 35\")\n\n\n\n\n\nSom vi ser så är det knappt någon skevhet. Testa själv att sätta medelvärdet (kallas lambda) till 100 så ser det väldigt bra ut."
  },
  {
    "objectID": "tutorials/transformations/index.html#log-transformering",
    "href": "tutorials/transformations/index.html#log-transformering",
    "title": "Transformeringar",
    "section": "log-transformering",
    "text": "log-transformering\nEn annan vanlig typ av transformering är log-transformering, vilket man kan överväga i följande fall\n\nData är extremt höger-skevt (se plot nedan).\nData beskriver en multiplikativ eller exponentiell process, till exempel tillväxt eller ibland vikt\nVariansen ökar kraftigt med medelvärdet\n\nVi börjar med att simulera data från en exponentiell fördelning och studerar histogrammet. Som du ser är datat kraftigt höger-skevt med några extrema värden som är mycket större än de övriga.\n\n\nCode\nset.seed (12768)\nexp.data<-rlnorm(n = 50, 3,1)\nhist(exp.data, main=\"Histogram of exponential data\",col=\"blue\")\n\n\n\n\n\nFör att analysera den här typen av data och kunna lite på de p-värden vi får i vår analys behöver vi log-transformera vår responsvariabel. Vi gör det med funktionen log().\nPå samma sätt som kvadrat-rots-transformering så minskar log-transformeringen höga tal mer än låga tal, vilket ger en jämnare fördelning. Log-transformeringen är dock ännu kraftigare, vilket vi kan se i tabellen nedan.\n\n\n\nTal\nLogaritmen av talet\nHur mycket minskar talet\n\n\n\n\n2\n0.69\n1.31\n\n\n10\n2.30\n7.70\n\n\n\nVi tittar på ett histogram när vi log-transformerat vår data.\n\n\nCode\nhist(log(exp.data),col=\"blue\", main=\"Histogram of exponential data after log transformation\")\n\n\n\n\n\nSom vi ser så gör log-transformeringen att vårt kraftigt höger-skeva data antar något som mer liknar en normalfördelning. Notera åter igen att vi inte skall log-transformera data som redan är normalfördelat, då förstör vi en bra fördelning."
  },
  {
    "objectID": "tutorials/transformations/index.html#test-för-normalfördelning",
    "href": "tutorials/transformations/index.html#test-för-normalfördelning",
    "title": "Transformeringar",
    "section": "Test för normalfördelning",
    "text": "Test för normalfördelning\nJag rekommenderar inte att du testar för normalfördelning om du har stora dataset. Testen undersöker avvikelse från normalfördelning, och ju mer data du har, desto kraftfullare blir testen och kan upptäcka minimala avvikelser som inte spelar någon praktisk roll för de statistiska testen. Men om du ändå vill ha ett test så använd Shapiro Wilk’s test, i funktionen shapiro.test()\nFörst gör vi ett Shapiro test på vår exponentiella fördelning:\n\nshapiro.test(exp.data)\n\n\n    Shapiro-Wilk normality test\n\ndata:  exp.data\nW = 0.82092, p-value = 2.756e-06\n\n\nTestet är signifikant, dvs data avviker signifikant från normalfördelning.\nOm testet är icke-signifikant betyder det att data inte avviker från normalfördelning (dvs data är normalfördelat). Vi testar på vårt log-transformerade data:\n\n\nCode\nshapiro.test(log(exp.data))\n\n\n\n    Shapiro-Wilk normality test\n\ndata:  log(exp.data)\nW = 0.97929, p-value = 0.5224\n\n\nTestet är inte signifikant, dvs data avviker inte från normalfördelning (dvs är normalfördelat) efter att vi transformerat det med log().\n\nProblemet med test för normalfördelning\nOm histogram och QQplot ser bra ut, men du ändå får en signifikant avvikelse från normalfördelning (speciellt vid större dataset) skulle jag lita på histogramen och QQ plot. Eftersom alla statistiska test blir kraftfullare ju mer data du har så kan Shapiro-Wilks test säga att data avviker från normalfördelning fast det i alla praktiska bemärkelser kan räknas som normalfördelat data.\nSom ett exempel på problemen med test för normalfördelning så simulerar jag 2000 värden från en normalfördelning:\n\n\nCode\nset.seed(62874)\n\nsimdata <- rnorm(mean = 100, sd = 50, n = 2000)\n\n\nVi gör sedan ett histogram - det ser extremt normalfördelat ut!\n\n\nCode\nhist(simdata)\n\n\n\n\n\nEn QQ-plot ser även den väldigt bra ut, så här bra har jag nog aldrig sett en QQ plot som varit baserad på riktiga data.\n\n\nCode\nqqnorm(simdata)\nqqline(simdata)\n\n\n\n\n\nMen tack vare att vi har så många värden så tycker Shapiro Wilk’s test att våra data (som vi vet kommer från en normalfördelning) signifikant avviker från normalfördelningen.\n\n\nCode\nshapiro.test(simdata)\n\n\n\n    Shapiro-Wilk normality test\n\ndata:  simdata\nW = 0.99833, p-value = 0.04167\n\n\nDärför skall du inte lita blint på Shapiro´s test, det är mycket bättre att titta på histogram och QQ plot."
  },
  {
    "objectID": "tutorials/transformations/index.html#qq-plot---grafisk-inspektion-av-normalfördelning",
    "href": "tutorials/transformations/index.html#qq-plot---grafisk-inspektion-av-normalfördelning",
    "title": "Transformeringar",
    "section": "QQ-Plot - Grafisk inspektion av normalfördelning",
    "text": "QQ-Plot - Grafisk inspektion av normalfördelning\nFörutom att titta på histogram så är en mycket vanlig metod för att inspektera om data följer en normalfördelning att göra en QQ-Plot.\nNedan följer en QQ plot på normalfördelat data.\n\n\nCode\nqqnorm(norm.data)\nqqline(norm.data)\n\n\n\n\n\nVi ser att alla datapunkter faller mer eller mindre på den diagonala linjen, dvs våra mätvärden (på y-axeln) motsvarar nästan perfekt våra förväntade mätvärden om de skulle komma från en normalfördelning (x-axeln). Så här bra ser sällan en QQ plot ut, speciellt låga och höga värden brukar avvika lite, men vi vill inte se en systematisk avvikelse.\nLåt oss titta på en QQ-plot för våra exponentiella data\n\nqqnorm(exp.data,col=\"blue\")\nqqline(exp.data)\n\n\n\n\nÄven om man sällan ser att alla punkterna faller precis på linjen (speciellt punkterna i ändarna av fördelningen kan ofta ligga en liten bit från linjen) så skall vi inte se ett tydligt mönster så som vi ser här, och vi ser att framför allt de höga värderna avviker kraftigt från den förväntade fördelningen. Det här tyder på att datat inte är normalfördelat.\nVi testar det på log-transformerat data:\n\n\nCode\nqqnorm(log(exp.data),col=\"blue\")\nqqline(log(exp.data))"
  }
]